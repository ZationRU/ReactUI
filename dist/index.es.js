import * as React from 'react';
import React__default, { useState, useRef, useEffect, useCallback } from 'react';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This file is automatically generated. Do not modify it.
/**
 * Utility methods for mathematical operations.
 */
/**
 * The signum function.
 *
 * @return 1 if num > 0, -1 if num < 0, and 0 if num = 0
 */
function signum(num) {
    if (num < 0) {
        return -1;
    }
    else if (num === 0) {
        return 0;
    }
    else {
        return 1;
    }
}
/**
 * The linear interpolation function.
 *
 * @return start if amount = 0 and stop if amount = 1
 */
function lerp(start, stop, amount) {
    return (1.0 - amount) * start + amount * stop;
}
/**
 * Clamps an integer between two integers.
 *
 * @return input when min <= input <= max, and either min or max
 * otherwise.
 */
function clampInt(min, max, input) {
    if (input < min) {
        return min;
    }
    else if (input > max) {
        return max;
    }
    return input;
}
/**
 * Sanitizes a degree measure as a floating-point number.
 *
 * @return a degree measure between 0.0 (inclusive) and 360.0
 * (exclusive).
 */
function sanitizeDegreesDouble(degrees) {
    degrees = degrees % 360.0;
    if (degrees < 0) {
        degrees = degrees + 360.0;
    }
    return degrees;
}
/**
 * Sign of direction change needed to travel from one angle to
 * another.
 *
 * For angles that are 180 degrees apart from each other, both
 * directions have the same travel distance, so either direction is
 * shortest. The value 1.0 is returned in this case.
 *
 * @param from The angle travel starts from, in degrees.
 * @param to The angle travel ends at, in degrees.
 * @return -1 if decreasing from leads to the shortest travel
 * distance, 1 if increasing from leads to the shortest travel
 * distance.
 */
function rotationDirection(from, to) {
    const increasingDifference = sanitizeDegreesDouble(to - from);
    return increasingDifference <= 180.0 ? 1.0 : -1.0;
}
/**
 * Distance of two points on a circle, represented using degrees.
 */
function differenceDegrees(a, b) {
    return 180.0 - Math.abs(Math.abs(a - b) - 180.0);
}
/**
 * Multiplies a 1x3 row vector with a 3x3 matrix.
 */
function matrixMultiply(row, matrix) {
    const a = row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
    const b = row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
    const c = row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
    return [a, b, c];
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Color science utilities.
 *
 * Utility methods for color science constants and color space
 * conversions that aren't HCT or CAM16.
 */
const SRGB_TO_XYZ = [
    [0.41233895, 0.35762064, 0.18051042],
    [0.2126, 0.7152, 0.0722],
    [0.01932141, 0.11916382, 0.95034478],
];
const XYZ_TO_SRGB = [
    [
        3.2413774792388685,
        -1.5376652402851851,
        -0.49885366846268053,
    ],
    [
        -0.9691452513005321,
        1.8758853451067872,
        0.04156585616912061,
    ],
    [
        0.05562093689691305,
        -0.20395524564742123,
        1.0571799111220335,
    ],
];
const WHITE_POINT_D65 = [95.047, 100.0, 108.883];
/**
 * Converts a color from RGB components to ARGB format.
 */
function argbFromRgb(red, green, blue) {
    return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>>
        0;
}
/**
 * Converts a color from linear RGB components to ARGB format.
 */
function argbFromLinrgb(linrgb) {
    const r = delinearized(linrgb[0]);
    const g = delinearized(linrgb[1]);
    const b = delinearized(linrgb[2]);
    return argbFromRgb(r, g, b);
}
/**
 * Returns the red component of a color in ARGB format.
 */
function redFromArgb(argb) {
    return argb >> 16 & 255;
}
/**
 * Returns the green component of a color in ARGB format.
 */
function greenFromArgb(argb) {
    return argb >> 8 & 255;
}
/**
 * Returns the blue component of a color in ARGB format.
 */
function blueFromArgb(argb) {
    return argb & 255;
}
/**
 * Converts a color from ARGB to XYZ.
 */
function argbFromXyz(x, y, z) {
    const matrix = XYZ_TO_SRGB;
    const linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
    const linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
    const linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
    const r = delinearized(linearR);
    const g = delinearized(linearG);
    const b = delinearized(linearB);
    return argbFromRgb(r, g, b);
}
/**
 * Converts a color from XYZ to ARGB.
 */
function xyzFromArgb(argb) {
    const r = linearized(redFromArgb(argb));
    const g = linearized(greenFromArgb(argb));
    const b = linearized(blueFromArgb(argb));
    return matrixMultiply([r, g, b], SRGB_TO_XYZ);
}
/**
 * Converts an L* value to an ARGB representation.
 *
 * @param lstar L* in L*a*b*
 * @return ARGB representation of grayscale color with lightness
 * matching L*
 */
function argbFromLstar(lstar) {
    const y = yFromLstar(lstar);
    const component = delinearized(y);
    return argbFromRgb(component, component, component);
}
/**
 * Computes the L* value of a color in ARGB representation.
 *
 * @param argb ARGB representation of a color
 * @return L*, from L*a*b*, coordinate of the color
 */
function lstarFromArgb(argb) {
    const y = xyzFromArgb(argb)[1];
    return 116.0 * labF(y / 100.0) - 16.0;
}
/**
 * Converts an L* value to a Y value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 *
 * @param lstar L* in L*a*b*
 * @return Y in XYZ
 */
function yFromLstar(lstar) {
    return 100.0 * labInvf((lstar + 16.0) / 116.0);
}
/**
 * Linearizes an RGB component.
 *
 * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B
 * channel
 * @return 0.0 <= output <= 100.0, color channel converted to
 * linear RGB space
 */
function linearized(rgbComponent) {
    const normalized = rgbComponent / 255.0;
    if (normalized <= 0.040449936) {
        return normalized / 12.92 * 100.0;
    }
    else {
        return Math.pow((normalized + 0.055) / 1.055, 2.4) * 100.0;
    }
}
/**
 * Delinearizes an RGB component.
 *
 * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
 * linear R/G/B channel
 * @return 0 <= output <= 255, color channel converted to regular
 * RGB space
 */
function delinearized(rgbComponent) {
    const normalized = rgbComponent / 100.0;
    let delinearized = 0.0;
    if (normalized <= 0.0031308) {
        delinearized = normalized * 12.92;
    }
    else {
        delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
    }
    return clampInt(0, 255, Math.round(delinearized * 255.0));
}
/**
 * Returns the standard white point; white on a sunny day.
 *
 * @return The white point
 */
function whitePointD65() {
    return WHITE_POINT_D65;
}
function labF(t) {
    const e = 216.0 / 24389.0;
    const kappa = 24389.0 / 27.0;
    if (t > e) {
        return Math.pow(t, 1.0 / 3.0);
    }
    else {
        return (kappa * t + 16) / 116;
    }
}
function labInvf(ft) {
    const e = 216.0 / 24389.0;
    const kappa = 24389.0 / 27.0;
    const ft3 = ft * ft * ft;
    if (ft3 > e) {
        return ft3;
    }
    else {
        return (116 * ft - 16) / kappa;
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * In traditional color spaces, a color can be identified solely by the
 * observer's measurement of the color. Color appearance models such as CAM16
 * also use information about the environment where the color was
 * observed, known as the viewing conditions.
 *
 * For example, white under the traditional assumption of a midday sun white
 * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
 * hue 203, chroma 3, lightness 100)
 *
 * This class caches intermediate values of the CAM16 conversion process that
 * depend only on viewing conditions, enabling speed ups.
 */
class ViewingConditions {
    /**
     * Parameters are intermediate values of the CAM16 conversion process. Their
     * names are shorthand for technical color science terminology, this class
     * would not benefit from documenting them individually. A brief overview
     * is available in the CAM16 specification, and a complete overview requires
     * a color science textbook, such as Fairchild's Color Appearance Models.
     */
    constructor(n, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
        this.n = n;
        this.aw = aw;
        this.nbb = nbb;
        this.ncb = ncb;
        this.c = c;
        this.nc = nc;
        this.rgbD = rgbD;
        this.fl = fl;
        this.fLRoot = fLRoot;
        this.z = z;
    }
    /**
     * Create ViewingConditions from a simple, physically relevant, set of
     * parameters.
     *
     * @param whitePoint White point, measured in the XYZ color space.
     *     default = D65, or sunny day afternoon
     * @param adaptingLuminance The luminance of the adapting field. Informally,
     *     how bright it is in the room where the color is viewed. Can be
     *     calculated from lux by multiplying lux by 0.0586. default = 11.72,
     *     or 200 lux.
     * @param backgroundLstar The lightness of the area surrounding the color.
     *     measured by L* in L*a*b*. default = 50.0
     * @param surround A general description of the lighting surrounding the
     *     color. 0 is pitch dark, like watching a movie in a theater. 1.0 is a
     *     dimly light room, like watching TV at home at night. 2.0 means there
     *     is no difference between the lighting on the color and around it.
     *     default = 2.0
     * @param discountingIlluminant Whether the eye accounts for the tint of the
     *     ambient lighting, such as knowing an apple is still red in green light.
     *     default = false, the eye does not perform this process on
     *       self-luminous objects like displays.
     */
    static make(whitePoint = whitePointD65(), adaptingLuminance = (200.0 / Math.PI) * yFromLstar(50.0) / 100.0, backgroundLstar = 50.0, surround = 2.0, discountingIlluminant = false) {
        const xyz = whitePoint;
        const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
        const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
        const bW = xyz[0] * -0.002079 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
        const f = 0.8 + surround / 10.0;
        const c = f >= 0.9 ? lerp(0.59, 0.69, (f - 0.9) * 10.0) :
            lerp(0.525, 0.59, (f - 0.8) * 10.0);
        let d = discountingIlluminant ?
            1.0 :
            f * (1.0 - (1.0 / 3.6) * Math.exp((-adaptingLuminance - 42.0) / 92.0));
        d = d > 1.0 ? 1.0 : d < 0.0 ? 0.0 : d;
        const nc = f;
        const rgbD = [
            d * (100.0 / rW) + 1.0 - d,
            d * (100.0 / gW) + 1.0 - d,
            d * (100.0 / bW) + 1.0 - d,
        ];
        const k = 1.0 / (5.0 * adaptingLuminance + 1.0);
        const k4 = k * k * k * k;
        const k4F = 1.0 - k4;
        const fl = k4 * adaptingLuminance +
            0.1 * k4F * k4F * Math.cbrt(5.0 * adaptingLuminance);
        const n = yFromLstar(backgroundLstar) / whitePoint[1];
        const z = 1.48 + Math.sqrt(n);
        const nbb = 0.725 / Math.pow(n, 0.2);
        const ncb = nbb;
        const rgbAFactors = [
            Math.pow((fl * rgbD[0] * rW) / 100.0, 0.42),
            Math.pow((fl * rgbD[1] * gW) / 100.0, 0.42),
            Math.pow((fl * rgbD[2] * bW) / 100.0, 0.42),
        ];
        const rgbA = [
            (400.0 * rgbAFactors[0]) / (rgbAFactors[0] + 27.13),
            (400.0 * rgbAFactors[1]) / (rgbAFactors[1] + 27.13),
            (400.0 * rgbAFactors[2]) / (rgbAFactors[2] + 27.13),
        ];
        const aw = (2.0 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
        return new ViewingConditions(n, aw, nbb, ncb, c, nc, rgbD, fl, Math.pow(fl, 0.25), z);
    }
}
/** sRGB-like viewing conditions.  */
ViewingConditions.DEFAULT = ViewingConditions.make();

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * CAM16, a color appearance model. Colors are not just defined by their hex
 * code, but rather, a hex code and viewing conditions.
 *
 * CAM16 instances also have coordinates in the CAM16-UCS space, called J*, a*,
 * b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
 * specification, and should be used when measuring distances between colors.
 *
 * In traditional color spaces, a color can be identified solely by the
 * observer's measurement of the color. Color appearance models such as CAM16
 * also use information about the environment where the color was
 * observed, known as the viewing conditions.
 *
 * For example, white under the traditional assumption of a midday sun white
 * point is accurately measured as a slightly chromatic blue by CAM16. (roughly,
 * hue 203, chroma 3, lightness 100)
 */
class Cam16 {
    /**
     * All of the CAM16 dimensions can be calculated from 3 of the dimensions, in
     * the following combinations:
     *      -  {j or q} and {c, m, or s} and hue
     *      - jstar, astar, bstar
     * Prefer using a static method that constructs from 3 of those dimensions.
     * This constructor is intended for those methods to use to return all
     * possible dimensions.
     *
     * @param hue
     * @param chroma informally, colorfulness / color intensity. like saturation
     *     in HSL, except perceptually accurate.
     * @param j lightness
     * @param q brightness; ratio of lightness to white point's lightness
     * @param m colorfulness
     * @param s saturation; ratio of chroma to white point's chroma
     * @param jstar CAM16-UCS J coordinate
     * @param astar CAM16-UCS a coordinate
     * @param bstar CAM16-UCS b coordinate
     */
    constructor(hue, chroma, j, q, m, s, jstar, astar, bstar) {
        this.hue = hue;
        this.chroma = chroma;
        this.j = j;
        this.q = q;
        this.m = m;
        this.s = s;
        this.jstar = jstar;
        this.astar = astar;
        this.bstar = bstar;
    }
    /**
     * CAM16 instances also have coordinates in the CAM16-UCS space, called J*,
     * a*, b*, or jstar, astar, bstar in code. CAM16-UCS is included in the CAM16
     * specification, and is used to measure distances between colors.
     */
    distance(other) {
        const dJ = this.jstar - other.jstar;
        const dA = this.astar - other.astar;
        const dB = this.bstar - other.bstar;
        const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
        const dE = 1.41 * Math.pow(dEPrime, 0.63);
        return dE;
    }
    /**
     * @param argb ARGB representation of a color.
     * @return CAM16 color, assuming the color was viewed in default viewing
     *     conditions.
     */
    static fromInt(argb) {
        return Cam16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
    }
    /**
     * @param argb ARGB representation of a color.
     * @param viewingConditions Information about the environment where the color
     *     was observed.
     * @return CAM16 color.
     */
    static fromIntInViewingConditions(argb, viewingConditions) {
        const red = (argb & 0x00ff0000) >> 16;
        const green = (argb & 0x0000ff00) >> 8;
        const blue = (argb & 0x000000ff);
        const redL = linearized(red);
        const greenL = linearized(green);
        const blueL = linearized(blue);
        const x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
        const y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
        const z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;
        const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
        const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
        const bC = -0.002079 * x + 0.048952 * y + 0.953127 * z;
        const rD = viewingConditions.rgbD[0] * rC;
        const gD = viewingConditions.rgbD[1] * gC;
        const bD = viewingConditions.rgbD[2] * bC;
        const rAF = Math.pow((viewingConditions.fl * Math.abs(rD)) / 100.0, 0.42);
        const gAF = Math.pow((viewingConditions.fl * Math.abs(gD)) / 100.0, 0.42);
        const bAF = Math.pow((viewingConditions.fl * Math.abs(bD)) / 100.0, 0.42);
        const rA = (signum(rD) * 400.0 * rAF) / (rAF + 27.13);
        const gA = (signum(gD) * 400.0 * gAF) / (gAF + 27.13);
        const bA = (signum(bD) * 400.0 * bAF) / (bAF + 27.13);
        const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
        const b = (rA + gA - 2.0 * bA) / 9.0;
        const u = (20.0 * rA + 20.0 * gA + 21.0 * bA) / 20.0;
        const p2 = (40.0 * rA + 20.0 * gA + bA) / 20.0;
        const atan2 = Math.atan2(b, a);
        const atanDegrees = (atan2 * 180.0) / Math.PI;
        const hue = atanDegrees < 0 ? atanDegrees + 360.0 :
            atanDegrees >= 360 ? atanDegrees - 360.0 :
                atanDegrees;
        const hueRadians = (hue * Math.PI) / 180.0;
        const ac = p2 * viewingConditions.nbb;
        const j = 100.0 *
            Math.pow(ac / viewingConditions.aw, viewingConditions.c * viewingConditions.z);
        const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
            (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
        const huePrime = hue < 20.14 ? hue + 360 : hue;
        const eHue = 0.25 * (Math.cos((huePrime * Math.PI) / 180.0 + 2.0) + 3.8);
        const p1 = (50000.0 / 13.0) * eHue * viewingConditions.nc * viewingConditions.ncb;
        const t = (p1 * Math.sqrt(a * a + b * b)) / (u + 0.305);
        const alpha = Math.pow(t, 0.9) *
            Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
        const c = alpha * Math.sqrt(j / 100.0);
        const m = c * viewingConditions.fLRoot;
        const s = 50.0 *
            Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
        const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
        const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
        const astar = mstar * Math.cos(hueRadians);
        const bstar = mstar * Math.sin(hueRadians);
        return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
    }
    /**
     * @param j CAM16 lightness
     * @param c CAM16 chroma
     * @param h CAM16 hue
     */
    static fromJch(j, c, h) {
        return Cam16.fromJchInViewingConditions(j, c, h, ViewingConditions.DEFAULT);
    }
    /**
     * @param j CAM16 lightness
     * @param c CAM16 chroma
     * @param h CAM16 hue
     * @param viewingConditions Information about the environment where the color
     *     was observed.
     */
    static fromJchInViewingConditions(j, c, h, viewingConditions) {
        const q = (4.0 / viewingConditions.c) * Math.sqrt(j / 100.0) *
            (viewingConditions.aw + 4.0) * viewingConditions.fLRoot;
        const m = c * viewingConditions.fLRoot;
        const alpha = c / Math.sqrt(j / 100.0);
        const s = 50.0 *
            Math.sqrt((alpha * viewingConditions.c) / (viewingConditions.aw + 4.0));
        const hueRadians = (h * Math.PI) / 180.0;
        const jstar = ((1.0 + 100.0 * 0.007) * j) / (1.0 + 0.007 * j);
        const mstar = (1.0 / 0.0228) * Math.log(1.0 + 0.0228 * m);
        const astar = mstar * Math.cos(hueRadians);
        const bstar = mstar * Math.sin(hueRadians);
        return new Cam16(h, c, j, q, m, s, jstar, astar, bstar);
    }
    /**
     * @param jstar CAM16-UCS lightness.
     * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
     *     coordinate on the Y axis.
     * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
     *     coordinate on the X axis.
     */
    static fromUcs(jstar, astar, bstar) {
        return Cam16.fromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.DEFAULT);
    }
    /**
     * @param jstar CAM16-UCS lightness.
     * @param astar CAM16-UCS a dimension. Like a* in L*a*b*, it is a Cartesian
     *     coordinate on the Y axis.
     * @param bstar CAM16-UCS b dimension. Like a* in L*a*b*, it is a Cartesian
     *     coordinate on the X axis.
     * @param viewingConditions Information about the environment where the color
     *     was observed.
     */
    static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
        const a = astar;
        const b = bstar;
        const m = Math.sqrt(a * a + b * b);
        const M = (Math.exp(m * 0.0228) - 1.0) / 0.0228;
        const c = M / viewingConditions.fLRoot;
        let h = Math.atan2(b, a) * (180.0 / Math.PI);
        if (h < 0.0) {
            h += 360.0;
        }
        const j = jstar / (1 - (jstar - 100) * 0.007);
        return Cam16.fromJchInViewingConditions(j, c, h, viewingConditions);
    }
    /**
     *  @return ARGB representation of color, assuming the color was viewed in
     *     default viewing conditions, which are near-identical to the default
     *     viewing conditions for sRGB.
     */
    toInt() {
        return this.viewed(ViewingConditions.DEFAULT);
    }
    /**
     * @param viewingConditions Information about the environment where the color
     *     will be viewed.
     * @return ARGB representation of color
     */
    viewed(viewingConditions) {
        const alpha = this.chroma === 0.0 || this.j === 0.0 ?
            0.0 :
            this.chroma / Math.sqrt(this.j / 100.0);
        const t = Math.pow(alpha / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73), 1.0 / 0.9);
        const hRad = (this.hue * Math.PI) / 180.0;
        const eHue = 0.25 * (Math.cos(hRad + 2.0) + 3.8);
        const ac = viewingConditions.aw *
            Math.pow(this.j / 100.0, 1.0 / viewingConditions.c / viewingConditions.z);
        const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
        const p2 = ac / viewingConditions.nbb;
        const hSin = Math.sin(hRad);
        const hCos = Math.cos(hRad);
        const gamma = (23.0 * (p2 + 0.305) * t) /
            (23.0 * p1 + 11.0 * t * hCos + 108.0 * t * hSin);
        const a = gamma * hCos;
        const b = gamma * hSin;
        const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
        const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
        const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
        const rCBase = Math.max(0, (27.13 * Math.abs(rA)) / (400.0 - Math.abs(rA)));
        const rC = signum(rA) * (100.0 / viewingConditions.fl) *
            Math.pow(rCBase, 1.0 / 0.42);
        const gCBase = Math.max(0, (27.13 * Math.abs(gA)) / (400.0 - Math.abs(gA)));
        const gC = signum(gA) * (100.0 / viewingConditions.fl) *
            Math.pow(gCBase, 1.0 / 0.42);
        const bCBase = Math.max(0, (27.13 * Math.abs(bA)) / (400.0 - Math.abs(bA)));
        const bC = signum(bA) * (100.0 / viewingConditions.fl) *
            Math.pow(bCBase, 1.0 / 0.42);
        const rF = rC / viewingConditions.rgbD[0];
        const gF = gC / viewingConditions.rgbD[1];
        const bF = bC / viewingConditions.rgbD[2];
        const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
        const y = 0.38752654 * rF + 0.62144744 * gF - 0.00897398 * bF;
        const z = -0.01584150 * rF - 0.03412294 * gF + 1.04996444 * bF;
        const argb = argbFromXyz(x, y, z);
        return argb;
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// libmonet is designed to have a consistent API across platforms
// and modular components that can be moved around easily. Using a class as a
// namespace facilitates this.
//
// tslint:disable:class-as-namespace
/**
 * A class that solves the HCT equation.
 */
class HctSolver {
    /**
     * Sanitizes a small enough angle in radians.
     *
     * @param angle An angle in radians; must not deviate too much
     * from 0.
     * @return A coterminal angle between 0 and 2pi.
     */
    static sanitizeRadians(angle) {
        return (angle + Math.PI * 8) % (Math.PI * 2);
    }
    /**
     * Delinearizes an RGB component, returning a floating-point
     * number.
     *
     * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
     * linear R/G/B channel
     * @return 0.0 <= output <= 255.0, color channel converted to
     * regular RGB space
     */
    static trueDelinearized(rgbComponent) {
        const normalized = rgbComponent / 100.0;
        let delinearized = 0.0;
        if (normalized <= 0.0031308) {
            delinearized = normalized * 12.92;
        }
        else {
            delinearized = 1.055 * Math.pow(normalized, 1.0 / 2.4) - 0.055;
        }
        return delinearized * 255.0;
    }
    static chromaticAdaptation(component) {
        const af = Math.pow(Math.abs(component), 0.42);
        return signum(component) * 400.0 * af / (af + 27.13);
    }
    /**
     * Returns the hue of a linear RGB color in CAM16.
     *
     * @param linrgb The linear RGB coordinates of a color.
     * @return The hue of the color in CAM16, in radians.
     */
    static hueOf(linrgb) {
        const scaledDiscount = matrixMultiply(linrgb, HctSolver.SCALED_DISCOUNT_FROM_LINRGB);
        const rA = HctSolver.chromaticAdaptation(scaledDiscount[0]);
        const gA = HctSolver.chromaticAdaptation(scaledDiscount[1]);
        const bA = HctSolver.chromaticAdaptation(scaledDiscount[2]);
        // redness-greenness
        const a = (11.0 * rA + -12.0 * gA + bA) / 11.0;
        // yellowness-blueness
        const b = (rA + gA - 2.0 * bA) / 9.0;
        return Math.atan2(b, a);
    }
    static areInCyclicOrder(a, b, c) {
        const deltaAB = HctSolver.sanitizeRadians(b - a);
        const deltaAC = HctSolver.sanitizeRadians(c - a);
        return deltaAB < deltaAC;
    }
    /**
     * Solves the lerp equation.
     *
     * @param source The starting number.
     * @param mid The number in the middle.
     * @param target The ending number.
     * @return A number t such that lerp(source, target, t) = mid.
     */
    static intercept(source, mid, target) {
        return (mid - source) / (target - source);
    }
    static lerpPoint(source, t, target) {
        return [
            source[0] + (target[0] - source[0]) * t,
            source[1] + (target[1] - source[1]) * t,
            source[2] + (target[2] - source[2]) * t,
        ];
    }
    /**
     * Intersects a segment with a plane.
     *
     * @param source The coordinates of point A.
     * @param coordinate The R-, G-, or B-coordinate of the plane.
     * @param target The coordinates of point B.
     * @param axis The axis the plane is perpendicular with. (0: R, 1:
     * G, 2: B)
     * @return The intersection point of the segment AB with the plane
     * R=coordinate, G=coordinate, or B=coordinate
     */
    static setCoordinate(source, coordinate, target, axis) {
        const t = HctSolver.intercept(source[axis], coordinate, target[axis]);
        return HctSolver.lerpPoint(source, t, target);
    }
    static isBounded(x) {
        return 0.0 <= x && x <= 100.0;
    }
    /**
     * Returns the nth possible vertex of the polygonal intersection.
     *
     * @param y The Y value of the plane.
     * @param n The zero-based index of the point. 0 <= n <= 11.
     * @return The nth possible vertex of the polygonal intersection
     * of the y plane and the RGB cube, in linear RGB coordinates, if
     * it exists. If this possible vertex lies outside of the cube,
     * [-1.0, -1.0, -1.0] is returned.
     */
    static nthVertex(y, n) {
        const kR = HctSolver.Y_FROM_LINRGB[0];
        const kG = HctSolver.Y_FROM_LINRGB[1];
        const kB = HctSolver.Y_FROM_LINRGB[2];
        const coordA = n % 4 <= 1 ? 0.0 : 100.0;
        const coordB = n % 2 === 0 ? 0.0 : 100.0;
        if (n < 4) {
            const g = coordA;
            const b = coordB;
            const r = (y - g * kG - b * kB) / kR;
            if (HctSolver.isBounded(r)) {
                return [r, g, b];
            }
            else {
                return [-1.0, -1.0, -1.0];
            }
        }
        else if (n < 8) {
            const b = coordA;
            const r = coordB;
            const g = (y - r * kR - b * kB) / kG;
            if (HctSolver.isBounded(g)) {
                return [r, g, b];
            }
            else {
                return [-1.0, -1.0, -1.0];
            }
        }
        else {
            const r = coordA;
            const g = coordB;
            const b = (y - r * kR - g * kG) / kB;
            if (HctSolver.isBounded(b)) {
                return [r, g, b];
            }
            else {
                return [-1.0, -1.0, -1.0];
            }
        }
    }
    /**
     * Finds the segment containing the desired color.
     *
     * @param y The Y value of the color.
     * @param targetHue The hue of the color.
     * @return A list of two sets of linear RGB coordinates, each
     * corresponding to an endpoint of the segment containing the
     * desired color.
     */
    static bisectToSegment(y, targetHue) {
        let left = [-1.0, -1.0, -1.0];
        let right = left;
        let leftHue = 0.0;
        let rightHue = 0.0;
        let initialized = false;
        let uncut = true;
        for (let n = 0; n < 12; n++) {
            const mid = HctSolver.nthVertex(y, n);
            if (mid[0] < 0) {
                continue;
            }
            const midHue = HctSolver.hueOf(mid);
            if (!initialized) {
                left = mid;
                right = mid;
                leftHue = midHue;
                rightHue = midHue;
                initialized = true;
                continue;
            }
            if (uncut || HctSolver.areInCyclicOrder(leftHue, midHue, rightHue)) {
                uncut = false;
                if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                    right = mid;
                    rightHue = midHue;
                }
                else {
                    left = mid;
                    leftHue = midHue;
                }
            }
        }
        return [left, right];
    }
    static midpoint(a, b) {
        return [
            (a[0] + b[0]) / 2,
            (a[1] + b[1]) / 2,
            (a[2] + b[2]) / 2,
        ];
    }
    static criticalPlaneBelow(x) {
        return Math.floor(x - 0.5);
    }
    static criticalPlaneAbove(x) {
        return Math.ceil(x - 0.5);
    }
    /**
     * Finds a color with the given Y and hue on the boundary of the
     * cube.
     *
     * @param y The Y value of the color.
     * @param targetHue The hue of the color.
     * @return The desired color, in linear RGB coordinates.
     */
    static bisectToLimit(y, targetHue) {
        const segment = HctSolver.bisectToSegment(y, targetHue);
        let left = segment[0];
        let leftHue = HctSolver.hueOf(left);
        let right = segment[1];
        for (let axis = 0; axis < 3; axis++) {
            if (left[axis] !== right[axis]) {
                let lPlane = -1;
                let rPlane = 255;
                if (left[axis] < right[axis]) {
                    lPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(left[axis]));
                    rPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(right[axis]));
                }
                else {
                    lPlane = HctSolver.criticalPlaneAbove(HctSolver.trueDelinearized(left[axis]));
                    rPlane = HctSolver.criticalPlaneBelow(HctSolver.trueDelinearized(right[axis]));
                }
                for (let i = 0; i < 8; i++) {
                    if (Math.abs(rPlane - lPlane) <= 1) {
                        break;
                    }
                    else {
                        const mPlane = Math.floor((lPlane + rPlane) / 2.0);
                        const midPlaneCoordinate = HctSolver.CRITICAL_PLANES[mPlane];
                        const mid = HctSolver.setCoordinate(left, midPlaneCoordinate, right, axis);
                        const midHue = HctSolver.hueOf(mid);
                        if (HctSolver.areInCyclicOrder(leftHue, targetHue, midHue)) {
                            right = mid;
                            rPlane = mPlane;
                        }
                        else {
                            left = mid;
                            leftHue = midHue;
                            lPlane = mPlane;
                        }
                    }
                }
            }
        }
        return HctSolver.midpoint(left, right);
    }
    static inverseChromaticAdaptation(adapted) {
        const adaptedAbs = Math.abs(adapted);
        const base = Math.max(0, 27.13 * adaptedAbs / (400.0 - adaptedAbs));
        return signum(adapted) * Math.pow(base, 1.0 / 0.42);
    }
    /**
     * Finds a color with the given hue, chroma, and Y.
     *
     * @param hueRadians The desired hue in radians.
     * @param chroma The desired chroma.
     * @param y The desired Y.
     * @return The desired color as a hexadecimal integer, if found; 0
     * otherwise.
     */
    static findResultByJ(hueRadians, chroma, y) {
        // Initial estimate of j.
        let j = Math.sqrt(y) * 11.0;
        // ===========================================================
        // Operations inlined from Cam16 to avoid repeated calculation
        // ===========================================================
        const viewingConditions = ViewingConditions.DEFAULT;
        const tInnerCoeff = 1 / Math.pow(1.64 - Math.pow(0.29, viewingConditions.n), 0.73);
        const eHue = 0.25 * (Math.cos(hueRadians + 2.0) + 3.8);
        const p1 = eHue * (50000.0 / 13.0) * viewingConditions.nc * viewingConditions.ncb;
        const hSin = Math.sin(hueRadians);
        const hCos = Math.cos(hueRadians);
        for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            const jNormalized = j / 100.0;
            const alpha = chroma === 0.0 || j === 0.0 ? 0.0 : chroma / Math.sqrt(jNormalized);
            const t = Math.pow(alpha * tInnerCoeff, 1.0 / 0.9);
            const ac = viewingConditions.aw *
                Math.pow(jNormalized, 1.0 / viewingConditions.c / viewingConditions.z);
            const p2 = ac / viewingConditions.nbb;
            const gamma = 23.0 * (p2 + 0.305) * t /
                (23.0 * p1 + 11 * t * hCos + 108.0 * t * hSin);
            const a = gamma * hCos;
            const b = gamma * hSin;
            const rA = (460.0 * p2 + 451.0 * a + 288.0 * b) / 1403.0;
            const gA = (460.0 * p2 - 891.0 * a - 261.0 * b) / 1403.0;
            const bA = (460.0 * p2 - 220.0 * a - 6300.0 * b) / 1403.0;
            const rCScaled = HctSolver.inverseChromaticAdaptation(rA);
            const gCScaled = HctSolver.inverseChromaticAdaptation(gA);
            const bCScaled = HctSolver.inverseChromaticAdaptation(bA);
            const linrgb = matrixMultiply([rCScaled, gCScaled, bCScaled], HctSolver.LINRGB_FROM_SCALED_DISCOUNT);
            // ===========================================================
            // Operations inlined from Cam16 to avoid repeated calculation
            // ===========================================================
            if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) {
                return 0;
            }
            const kR = HctSolver.Y_FROM_LINRGB[0];
            const kG = HctSolver.Y_FROM_LINRGB[1];
            const kB = HctSolver.Y_FROM_LINRGB[2];
            const fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
            if (fnj <= 0) {
                return 0;
            }
            if (iterationRound === 4 || Math.abs(fnj - y) < 0.002) {
                if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) {
                    return 0;
                }
                return argbFromLinrgb(linrgb);
            }
            // Iterates with Newton method,
            // Using 2 * fn(j) / j as the approximation of fn'(j)
            j = j - (fnj - y) * j / (2 * fnj);
        }
        return 0;
    }
    /**
     * Finds an sRGB color with the given hue, chroma, and L*, if
     * possible.
     *
     * @param hueDegrees The desired hue, in degrees.
     * @param chroma The desired chroma.
     * @param lstar The desired L*.
     * @return A hexadecimal representing the sRGB color. The color
     * has sufficiently close hue, chroma, and L* to the desired
     * values, if possible; otherwise, the hue and L* will be
     * sufficiently close, and chroma will be maximized.
     */
    static solveToInt(hueDegrees, chroma, lstar) {
        if (chroma < 0.0001 || lstar < 0.0001 || lstar > 99.9999) {
            return argbFromLstar(lstar);
        }
        hueDegrees = sanitizeDegreesDouble(hueDegrees);
        const hueRadians = hueDegrees / 180 * Math.PI;
        const y = yFromLstar(lstar);
        const exactAnswer = HctSolver.findResultByJ(hueRadians, chroma, y);
        if (exactAnswer !== 0) {
            return exactAnswer;
        }
        const linrgb = HctSolver.bisectToLimit(y, hueRadians);
        return argbFromLinrgb(linrgb);
    }
    /**
     * Finds an sRGB color with the given hue, chroma, and L*, if
     * possible.
     *
     * @param hueDegrees The desired hue, in degrees.
     * @param chroma The desired chroma.
     * @param lstar The desired L*.
     * @return An CAM16 object representing the sRGB color. The color
     * has sufficiently close hue, chroma, and L* to the desired
     * values, if possible; otherwise, the hue and L* will be
     * sufficiently close, and chroma will be maximized.
     */
    static solveToCam(hueDegrees, chroma, lstar) {
        return Cam16.fromInt(HctSolver.solveToInt(hueDegrees, chroma, lstar));
    }
}
HctSolver.SCALED_DISCOUNT_FROM_LINRGB = [
    [
        0.001200833568784504,
        0.002389694492170889,
        0.0002795742885861124,
    ],
    [
        0.0005891086651375999,
        0.0029785502573438758,
        0.0003270666104008398,
    ],
    [
        0.00010146692491640572,
        0.0005364214359186694,
        0.0032979401770712076,
    ],
];
HctSolver.LINRGB_FROM_SCALED_DISCOUNT = [
    [
        1373.2198709594231,
        -1100.4251190754821,
        -7.278681089101213,
    ],
    [
        -271.815969077903,
        559.6580465940733,
        -32.46047482791194,
    ],
    [
        1.9622899599665666,
        -57.173814538844006,
        308.7233197812385,
    ],
];
HctSolver.Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
HctSolver.CRITICAL_PLANES = [
    0.015176349177441876, 0.045529047532325624, 0.07588174588720938,
    0.10623444424209313, 0.13658714259697685, 0.16693984095186062,
    0.19729253930674434, 0.2276452376616281, 0.2579979360165119,
    0.28835063437139563, 0.3188300904430532, 0.350925934958123,
    0.3848314933096426, 0.42057480301049466, 0.458183274052838,
    0.4976837250274023, 0.5391024159806381, 0.5824650784040898,
    0.6277969426914107, 0.6751227633498623, 0.7244668422128921,
    0.775853049866786, 0.829304845476233, 0.8848452951698498,
    0.942497089126609, 1.0022825574869039, 1.0642236851973577,
    1.1283421258858297, 1.1946592148522128, 1.2631959812511864,
    1.3339731595349034, 1.407011200216447, 1.4823302800086415,
    1.5599503113873272, 1.6398909516233677, 1.7221716113234105,
    1.8068114625156377, 1.8938294463134073, 1.9832442801866852,
    2.075074464868551, 2.1693382909216234, 2.2660538449872063,
    2.36523901573795, 2.4669114995532007, 2.5710888059345764,
    2.6777882626779785, 2.7870270208169257, 2.898822059350997,
    3.0131901897720907, 3.1301480604002863, 3.2497121605402226,
    3.3718988244681087, 3.4967242352587946, 3.624204428461639,
    3.754355295633311, 3.887192587735158, 4.022731918402185,
    4.160988767090289, 4.301978482107941, 4.445716283538092,
    4.592217266055746, 4.741496401646282, 4.893568542229298,
    5.048448422192488, 5.20615066083972, 5.3666897647573375,
    5.5300801301023865, 5.696336044816294, 5.865471690767354,
    6.037501145825082, 6.212438385869475, 6.390297286737924,
    6.571091626112461, 6.7548350853498045, 6.941541251256611,
    7.131223617812143, 7.323895587840543, 7.5195704746346665,
    7.7182615035334345, 7.919981813454504, 8.124744458384042,
    8.332562408825165, 8.543448553206703, 8.757415699253682,
    8.974476575321063, 9.194643831691977, 9.417930041841839,
    9.644347703669503, 9.873909240696694, 10.106627003236781,
    10.342513269534024, 10.58158024687427, 10.8238400726681,
    11.069304815507364, 11.317986476196008, 11.569896988756009,
    11.825048221409341, 12.083451977536606, 12.345119996613247,
    12.610063955123938, 12.878295467455942, 13.149826086772048,
    13.42466730586372, 13.702830557985108, 13.984327217668513,
    14.269168601521828, 14.55736596900856, 14.848930523210871,
    15.143873411576273, 15.44220572664832, 15.743938506781891,
    16.04908273684337, 16.35764934889634, 16.66964922287304,
    16.985093187232053, 17.30399201960269, 17.62635644741625,
    17.95219714852476, 18.281524751807332, 18.614349837764564,
    18.95068293910138, 19.290534541298456, 19.633915083172692,
    19.98083495742689, 20.331304511189067, 20.685334046541502,
    21.042933821039977, 21.404114048223256, 21.76888489811322,
    22.137256497705877, 22.50923893145328, 22.884842241736916,
    23.264076429332462, 23.6469514538663, 24.033477234264016,
    24.42366364919083, 24.817520537484558, 25.21505769858089,
    25.61628489293138, 26.021211842414342, 26.429848230738664,
    26.842203703840827, 27.258287870275353, 27.678110301598522,
    28.10168053274597, 28.529008062403893, 28.96010235337422,
    29.39497283293396, 29.83362889318845, 30.276079891419332,
    30.722335150426627, 31.172403958865512, 31.62629557157785,
    32.08401920991837, 32.54558406207592, 33.010999283389665,
    33.4802739966603, 33.953417292456834, 34.430438229418264,
    34.911345834551085, 35.39614910352207, 35.88485700094671,
    36.37747846067349, 36.87402238606382, 37.37449765026789,
    37.87891309649659, 38.38727753828926, 38.89959975977785,
    39.41588851594697, 39.93615253289054, 40.460400508064545,
    40.98864111053629, 41.520882981230194, 42.05713473317016,
    42.597404951718396, 43.141702194811224, 43.6900349931913,
    44.24241185063697, 44.798841244188324, 45.35933162437017,
    45.92389141541209, 46.49252901546552, 47.065252796817916,
    47.64207110610409, 48.22299226451468, 48.808024568002054,
    49.3971762874833, 49.9904556690408, 50.587870934119984,
    51.189430279724725, 51.79514187861014, 52.40501387947288,
    53.0190544071392, 53.637271562750364, 54.259673423945976,
    54.88626804504493, 55.517063457223934, 56.15206766869424,
    56.79128866487574, 57.43473440856916, 58.08241284012621,
    58.734331877617365, 59.39049941699807, 60.05092333227251,
    60.715611475655585, 61.38457167773311, 62.057811747619894,
    62.7353394731159, 63.417162620860914, 64.10328893648692,
    64.79372614476921, 65.48848194977529, 66.18756403501224,
    66.89098006357258, 67.59873767827808, 68.31084450182222,
    69.02730813691093, 69.74813616640164, 70.47333615344107,
    71.20291564160104, 71.93688215501312, 72.67524319850172,
    73.41800625771542, 74.16517879925733, 74.9167682708136,
    75.67278210128072, 76.43322770089146, 77.1981124613393,
    77.96744375590167, 78.74122893956174, 79.51947534912904,
    80.30219030335869, 81.08938110306934, 81.88105503125999,
    82.67721935322541, 83.4778813166706, 84.28304815182372,
    85.09272707154808, 85.90692527145302, 86.72564993000343,
    87.54890820862819, 88.3767072518277, 89.2090541872801,
    90.04595612594655, 90.88742016217518, 91.73345337380438,
    92.58406282226491, 93.43925555268066, 94.29903859396902,
    95.16341895893969, 96.03240364439274, 96.9059996312159,
    97.78421388448044, 98.6670533535366, 99.55452497210776,
];

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * HCT, hue, chroma, and tone. A color system that provides a perceptually
 * accurate color measurement system that can also accurately render what colors
 * will appear as in different lighting environments.
 */
class Hct {
    constructor(argb) {
        this.argb = argb;
        const cam = Cam16.fromInt(argb);
        this.internalHue = cam.hue;
        this.internalChroma = cam.chroma;
        this.internalTone = lstarFromArgb(argb);
        this.argb = argb;
    }
    static from(hue, chroma, tone) {
        return new Hct(HctSolver.solveToInt(hue, chroma, tone));
    }
    /**
     * @param argb ARGB representation of a color.
     * @return HCT representation of a color in default viewing conditions
     */
    static fromInt(argb) {
        return new Hct(argb);
    }
    toInt() {
        return this.argb;
    }
    /**
     * A number, in degrees, representing ex. red, orange, yellow, etc.
     * Ranges from 0 <= hue < 360.
     */
    get hue() {
        return this.internalHue;
    }
    /**
     * @param newHue 0 <= newHue < 360; invalid values are corrected.
     * Chroma may decrease because chroma has a different maximum for any given
     * hue and tone.
     */
    set hue(newHue) {
        this.setInternalState(HctSolver.solveToInt(newHue, this.internalChroma, this.internalTone));
    }
    get chroma() {
        return this.internalChroma;
    }
    /**
     * @param newChroma 0 <= newChroma < ?
     * Chroma may decrease because chroma has a different maximum for any given
     * hue and tone.
     */
    set chroma(newChroma) {
        this.setInternalState(HctSolver.solveToInt(this.internalHue, newChroma, this.internalTone));
    }
    /** Lightness. Ranges from 0 to 100. */
    get tone() {
        return this.internalTone;
    }
    /**
     * @param newTone 0 <= newTone <= 100; invalid valids are corrected.
     * Chroma may decrease because chroma has a different maximum for any given
     * hue and tone.
     */
    set tone(newTone) {
        this.setInternalState(HctSolver.solveToInt(this.internalHue, this.internalChroma, newTone));
    }
    setInternalState(argb) {
        const cam = Cam16.fromInt(argb);
        this.internalHue = cam.hue;
        this.internalChroma = cam.chroma;
        this.internalTone = lstarFromArgb(argb);
        this.argb = argb;
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// libmonet is designed to have a consistent API across platforms
// and modular components that can be moved around easily. Using a class as a
// namespace facilitates this.
//
// tslint:disable:class-as-namespace
/**
 * Functions for blending in HCT and CAM16.
 */
class Blend {
    /**
     * Blend the design color's HCT hue towards the key color's HCT
     * hue, in a way that leaves the original color recognizable and
     * recognizably shifted towards the key color.
     *
     * @param designColor ARGB representation of an arbitrary color.
     * @param sourceColor ARGB representation of the main theme color.
     * @return The design color with a hue shifted towards the
     * system's color, a slightly warmer/cooler variant of the design
     * color's hue.
     */
    static harmonize(designColor, sourceColor) {
        const fromHct = Hct.fromInt(designColor);
        const toHct = Hct.fromInt(sourceColor);
        const differenceDegrees$1 = differenceDegrees(fromHct.hue, toHct.hue);
        const rotationDegrees = Math.min(differenceDegrees$1 * 0.5, 15.0);
        const outputHue = sanitizeDegreesDouble(fromHct.hue +
            rotationDegrees * rotationDirection(fromHct.hue, toHct.hue));
        return Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
    }
    /**
     * Blends hue from one color into another. The chroma and tone of
     * the original color are maintained.
     *
     * @param from ARGB representation of color
     * @param to ARGB representation of color
     * @param amount how much blending to perform; 0.0 >= and <= 1.0
     * @return from, with a hue blended towards to. Chroma and tone
     * are constant.
     */
    static hctHue(from, to, amount) {
        const ucs = Blend.cam16Ucs(from, to, amount);
        const ucsCam = Cam16.fromInt(ucs);
        const fromCam = Cam16.fromInt(from);
        const blended = Hct.from(ucsCam.hue, fromCam.chroma, lstarFromArgb(from));
        return blended.toInt();
    }
    /**
     * Blend in CAM16-UCS space.
     *
     * @param from ARGB representation of color
     * @param to ARGB representation of color
     * @param amount how much blending to perform; 0.0 >= and <= 1.0
     * @return from, blended towards to. Hue, chroma, and tone will
     * change.
     */
    static cam16Ucs(from, to, amount) {
        const fromCam = Cam16.fromInt(from);
        const toCam = Cam16.fromInt(to);
        const fromJ = fromCam.jstar;
        const fromA = fromCam.astar;
        const fromB = fromCam.bstar;
        const toJ = toCam.jstar;
        const toA = toCam.astar;
        const toB = toCam.bstar;
        const jstar = fromJ + (toJ - fromJ) * amount;
        const astar = fromA + (toA - fromA) * amount;
        const bstar = fromB + (toB - fromB) * amount;
        return Cam16.fromUcs(jstar, astar, bstar).toInt();
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *  A convenience class for retrieving colors that are constant in hue and
 *  chroma, but vary in tone.
 */
class TonalPalette {
    constructor(hue, chroma) {
        this.hue = hue;
        this.chroma = chroma;
        this.cache = new Map();
    }
    /**
     * @param argb ARGB representation of a color
     * @return Tones matching that color's hue and chroma.
     */
    static fromInt(argb) {
        const hct = Hct.fromInt(argb);
        return TonalPalette.fromHueAndChroma(hct.hue, hct.chroma);
    }
    /**
     * @param hue HCT hue
     * @param chroma HCT chroma
     * @return Tones matching hue and chroma.
     */
    static fromHueAndChroma(hue, chroma) {
        return new TonalPalette(hue, chroma);
    }
    /**
     * @param tone HCT tone, measured from 0 to 100.
     * @return ARGB representation of a color with that tone.
     */
    tone(tone) {
        let argb = this.cache.get(tone);
        if (argb === undefined) {
            argb = Hct.from(this.hue, this.chroma, tone).toInt();
            this.cache.set(tone, argb);
        }
        return argb;
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An intermediate concept between the key color for a UI theme, and a full
 * color scheme. 5 sets of tones are generated, all except one use the same hue
 * as the key color, and all vary in chroma.
 */
class CorePalette {
    constructor(argb, isContent) {
        const hct = Hct.fromInt(argb);
        const hue = hct.hue;
        const chroma = hct.chroma;
        if (isContent) {
            this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);
            this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3);
            this.a3 = TonalPalette.fromHueAndChroma(hue + 60, chroma / 2);
            this.n1 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 12, 4));
            this.n2 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 6, 8));
        }
        else {
            this.a1 = TonalPalette.fromHueAndChroma(hue, Math.max(48, chroma));
            this.a2 = TonalPalette.fromHueAndChroma(hue, 16);
            this.a3 = TonalPalette.fromHueAndChroma(hue + 60, 24);
            this.n1 = TonalPalette.fromHueAndChroma(hue, 4);
            this.n2 = TonalPalette.fromHueAndChroma(hue, 8);
        }
        this.error = TonalPalette.fromHueAndChroma(25, 84);
    }
    /**
     * @param argb ARGB representation of a color
     */
    static of(argb) {
        return new CorePalette(argb, false);
    }
    /**
     * @param argb ARGB representation of a color
     */
    static contentOf(argb) {
        return new CorePalette(argb, true);
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents a Material color scheme, a mapping of color roles to colors.
 */
class Scheme {
    constructor(props) {
        this.props = props;
    }
    get primary() {
        return this.props.primary;
    }
    get onPrimary() {
        return this.props.onPrimary;
    }
    get primaryContainer() {
        return this.props.primaryContainer;
    }
    get onPrimaryContainer() {
        return this.props.onPrimaryContainer;
    }
    get secondary() {
        return this.props.secondary;
    }
    get onSecondary() {
        return this.props.onSecondary;
    }
    get secondaryContainer() {
        return this.props.secondaryContainer;
    }
    get onSecondaryContainer() {
        return this.props.onSecondaryContainer;
    }
    get tertiary() {
        return this.props.tertiary;
    }
    get onTertiary() {
        return this.props.onTertiary;
    }
    get tertiaryContainer() {
        return this.props.tertiaryContainer;
    }
    get onTertiaryContainer() {
        return this.props.onTertiaryContainer;
    }
    get error() {
        return this.props.error;
    }
    get onError() {
        return this.props.onError;
    }
    get errorContainer() {
        return this.props.errorContainer;
    }
    get onErrorContainer() {
        return this.props.onErrorContainer;
    }
    get background() {
        return this.props.background;
    }
    get onBackground() {
        return this.props.onBackground;
    }
    get surface() {
        return this.props.surface;
    }
    get onSurface() {
        return this.props.onSurface;
    }
    get surfaceVariant() {
        return this.props.surfaceVariant;
    }
    get onSurfaceVariant() {
        return this.props.onSurfaceVariant;
    }
    get outline() {
        return this.props.outline;
    }
    get outlineVariant() {
        return this.props.outlineVariant;
    }
    get shadow() {
        return this.props.shadow;
    }
    get scrim() {
        return this.props.scrim;
    }
    get inverseSurface() {
        return this.props.inverseSurface;
    }
    get inverseOnSurface() {
        return this.props.inverseOnSurface;
    }
    get inversePrimary() {
        return this.props.inversePrimary;
    }
    /**
     * @param argb ARGB representation of a color.
     * @return Light Material color scheme, based on the color's hue.
     */
    static light(argb) {
        return Scheme.lightFromCorePalette(CorePalette.of(argb));
    }
    /**
     * @param argb ARGB representation of a color.
     * @return Dark Material color scheme, based on the color's hue.
     */
    static dark(argb) {
        return Scheme.darkFromCorePalette(CorePalette.of(argb));
    }
    /**
     * @param argb ARGB representation of a color.
     * @return Light Material content color scheme, based on the color's hue.
     */
    static lightContent(argb) {
        return Scheme.lightFromCorePalette(CorePalette.contentOf(argb));
    }
    /**
     * @param argb ARGB representation of a color.
     * @return Dark Material content color scheme, based on the color's hue.
     */
    static darkContent(argb) {
        return Scheme.darkFromCorePalette(CorePalette.contentOf(argb));
    }
    /**
     * Light scheme from core palette
     */
    static lightFromCorePalette(core) {
        return new Scheme({
            primary: core.a1.tone(40),
            onPrimary: core.a1.tone(100),
            primaryContainer: core.a1.tone(90),
            onPrimaryContainer: core.a1.tone(10),
            secondary: core.a2.tone(40),
            onSecondary: core.a2.tone(100),
            secondaryContainer: core.a2.tone(90),
            onSecondaryContainer: core.a2.tone(10),
            tertiary: core.a3.tone(40),
            onTertiary: core.a3.tone(100),
            tertiaryContainer: core.a3.tone(90),
            onTertiaryContainer: core.a3.tone(10),
            error: core.error.tone(40),
            onError: core.error.tone(100),
            errorContainer: core.error.tone(90),
            onErrorContainer: core.error.tone(10),
            background: core.n1.tone(99),
            onBackground: core.n1.tone(10),
            surface: core.n1.tone(99),
            onSurface: core.n1.tone(10),
            surfaceVariant: core.n2.tone(90),
            onSurfaceVariant: core.n2.tone(30),
            outline: core.n2.tone(50),
            outlineVariant: core.n2.tone(80),
            shadow: core.n1.tone(0),
            scrim: core.n1.tone(0),
            inverseSurface: core.n1.tone(20),
            inverseOnSurface: core.n1.tone(95),
            inversePrimary: core.a1.tone(80)
        });
    }
    /**
     * Dark scheme from core palette
     */
    static darkFromCorePalette(core) {
        return new Scheme({
            primary: core.a1.tone(80),
            onPrimary: core.a1.tone(20),
            primaryContainer: core.a1.tone(30),
            onPrimaryContainer: core.a1.tone(90),
            secondary: core.a2.tone(80),
            onSecondary: core.a2.tone(20),
            secondaryContainer: core.a2.tone(30),
            onSecondaryContainer: core.a2.tone(90),
            tertiary: core.a3.tone(80),
            onTertiary: core.a3.tone(20),
            tertiaryContainer: core.a3.tone(30),
            onTertiaryContainer: core.a3.tone(90),
            error: core.error.tone(80),
            onError: core.error.tone(20),
            errorContainer: core.error.tone(30),
            onErrorContainer: core.error.tone(80),
            background: core.n1.tone(10),
            onBackground: core.n1.tone(90),
            surface: core.n1.tone(10),
            onSurface: core.n1.tone(90),
            surfaceVariant: core.n2.tone(30),
            onSurfaceVariant: core.n2.tone(80),
            outline: core.n2.tone(60),
            outlineVariant: core.n2.tone(30),
            shadow: core.n1.tone(0),
            scrim: core.n1.tone(0),
            inverseSurface: core.n1.tone(90),
            inverseOnSurface: core.n1.tone(20),
            inversePrimary: core.a1.tone(40)
        });
    }
    toJSON() {
        return Object.assign({}, this.props);
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Generate a theme from a source color
 *
 * @param source Source color
 * @param customColors Array of custom colors
 * @return Theme object
 */
function themeFromSourceColor(source, customColors = []) {
    const palette = CorePalette.of(source);
    return {
        source,
        schemes: {
            light: Scheme.light(source),
            dark: Scheme.dark(source),
        },
        palettes: {
            primary: palette.a1,
            secondary: palette.a2,
            tertiary: palette.a3,
            neutral: palette.n1,
            neutralVariant: palette.n2,
            error: palette.error,
        },
        customColors: customColors.map((c) => customColor(source, c)),
    };
}
/**
 * Generate custom color group from source and target color
 *
 * @param source Source color
 * @param color Custom color
 * @return Custom color group
 *
 * @link https://m3.material.io/styles/color/the-color-system/color-roles
 */
function customColor(source, color) {
    let value = color.value;
    const from = value;
    const to = source;
    if (color.blend) {
        value = Blend.harmonize(from, to);
    }
    const palette = CorePalette.of(value);
    const tones = palette.a1;
    return {
        color,
        value,
        light: {
            color: tones.tone(40),
            onColor: tones.tone(100),
            colorContainer: tones.tone(90),
            onColorContainer: tones.tone(10),
        },
        dark: {
            color: tones.tone(80),
            onColor: tones.tone(20),
            colorContainer: tones.tone(30),
            onColorContainer: tones.tone(90),
        },
    };
}

var HARMONIZE_MAX_DEGREES = 15.0;
var HARMONIZE_PERCENTAGE = 0.5;
function classNames() {
    var classnames = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        classnames[_i] = arguments[_i];
    }
    return classnames.filter(function (it) { return it !== undefined; }).join(" ");
}
function harmonize(designColor, sourceColor) {
    console.log(CorePalette.of(designColor).n2.tone(90));
    var fromHct = Hct.fromInt(designColor);
    var toHct = Hct.fromInt(sourceColor);
    var differenceDegrees$1 = differenceDegrees(fromHct.hue, toHct.hue);
    var rotationDegrees = Math.min(differenceDegrees$1 * HARMONIZE_PERCENTAGE, HARMONIZE_MAX_DEGREES);
    var outputHue = sanitizeDegreesDouble(fromHct.hue
        + rotationDegrees * rotationDirection(fromHct.hue, toHct.hue));
    return Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
}

function TextInput(params) {
    var placeholder = params.placeholder, label = params.label, defaultValue = params.defaultValue, onChange = params.onChange, props = __rest(params, ["placeholder", "label", "defaultValue", "onChange"]);
    var _a = useState(defaultValue), text = _a[0], setText = _a[1];
    var _b = useState(false), focused = _b[0], setFocused = _b[1];
    return React__default.createElement("div", { className: classNames("TextInput", params.className) },
        React__default.createElement("fieldset", { className: classNames("TextInput-Inner", focused ? "TextInput-Inner-Focused" : undefined) },
            label && React__default.createElement("legend", { className: "TextInput-Label" }, label) || React__default.createElement("legend", { className: "TextInput-Label", style: { display: "none" } }),
            React__default.createElement("input", __assign({}, props, { onChange: function (event) {
                    setText(event.target.value);
                    onChange && onChange(event);
                }, onFocus: function () { return setFocused(true); }, onBlur: function () { return setFocused(false); }, placeholder: !focused ? placeholder : "", className: classNames("TextInput-Input"), "aria-label": label, defaultValue: text }))));
}

function TextArea(params) {
    var _a = useState(""), text = _a[0], setText = _a[1];
    var _b = params.placeholder, placeholder = _b === void 0 ? "" : _b, onChangeText = params.onChangeText, props = __rest(params, ["placeholder", "onChangeText"]);
    return React__default.createElement("div", { className: classNames("TextArea", params.className) },
        placeholder && text.length === 0 && React__default.createElement("div", { className: "TextArea-Placeholder" }, placeholder),
        React__default.createElement("div", __assign({}, props, { onInput: function (e) {
                setText(e.currentTarget.innerText);
                onChangeText && onChangeText({
                    target: e.currentTarget,
                    text: e.currentTarget.innerText
                });
            }, className: "TextArea-Inner", role: "textbox", contentEditable: "true", "aria-placeholder": "5-digit zipcode" })));
}

function Panel(params) {
    return React__default.createElement("div", null, params.children);
}

function Card(props) {
    return React__default.createElement("div", __assign({}, props, { className: classNames("Card", props.className) }));
}

function Hosts(props) {
    props.activePanel; var bottomNavigation = props.bottomNavigation, leftNavigation = props.leftNavigation, leftNavigationWidth = props.leftNavigationWidth, otherProps = __rest(props, ["activePanel", "bottomNavigation", "leftNavigation", "leftNavigationWidth"]);
    return React__default.createElement("div", __assign({}, otherProps, { className: classNames("Hosts", props.className) }),
        leftNavigation && React__default.createElement("div", { style: { width: leftNavigationWidth }, className: classNames("Hosts-Left") }, leftNavigation),
        React__default.createElement("div", { className: "Hosts-Content" }, !Array.isArray(props.children) ? props.children :
            props.children.find(function (it) { return it.props['id'] == props.activePanel; })),
        bottomNavigation && React__default.createElement(Card, { className: classNames("Hosts-Bottom") }, bottomNavigation));
}

function View(props) {
    return React__default.createElement("div", { className: "View" }, !Array.isArray(props.children) ? props.children :
        props.children.find(function (it) { return it.props['id'] == props.activePanel; }));
}

var _path$t, _circle$3;

function _extends$w() { _extends$w = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$w.apply(this, arguments); }

var SvgUserIcon = function SvgUserIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$w({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$t || (_path$t = /*#__PURE__*/React.createElement("path", {
    d: "M12 13C4.98297 13 3.43691 17.8631 3.09626 20.006C3.00956 20.5515 3.44772 21 4 21H20C20.5523 21 20.9904 20.5515 20.9037 20.006C20.5631 17.8631 19.017 13 12 13Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 1.5
  })), _circle$3 || (_circle$3 = /*#__PURE__*/React.createElement("circle", {
    cx: 12,
    cy: 6.5,
    r: 3.75,
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

function Avatar(_a) {
    var src = _a.src, size = _a.size, props = __rest(_a, ["src", "size"]);
    return React__default.createElement(Card, __assign({}, props, { className: classNames("Avatar", "Avatar-" + (size !== null && size !== void 0 ? size : "medium"), props.className) }), src ? React__default.createElement("img", { src: src, alt: "", loading: "lazy" }) :
        React__default.createElement(SvgUserIcon, null));
}

function AppRoot(params) {
    var _a = params.theme; _a === void 0 ? themeFromSourceColor(0x149C53) : _a;
    return React__default.createElement(React__default.Fragment, null,
        React__default.createElement("div", { className: "AppRoot" }, params.children));
}

function Div(params) {
    return React__default.createElement("div", __assign({}, params, { className: classNames("Div", params.className) }));
}

function GroupRoot(props) {
    return React__default.createElement(Div, null,
        React__default.createElement(Card, __assign({}, props)));
}

function Header(props) {
    var before = props.before, title = props.title, subtitle = props.subtitle, _a = props.mode, mode = _a === void 0 ? "primary" : _a, aside = props.aside, indicator = props.indicator, otherParams = __rest(props, ["before", "title", "subtitle", "mode", "aside", "indicator"]);
    return React__default.createElement("div", __assign({}, otherParams, { className: classNames("Header", otherParams.className) }),
        React__default.createElement("div", { className: classNames("Header-Titles", "Header-Titles--" + mode) },
            React__default.createElement("div", { className: "Header-Title" },
                before && React__default.createElement("div", { className: "Header-Before" }, before),
                React__default.createElement("span", null, title),
                indicator && React__default.createElement("div", { className: "Header-Indicator" }, indicator)),
            subtitle && React__default.createElement("div", { className: "Header-Subtitle" }, subtitle)),
        aside && React__default.createElement("div", { className: "Header-Aside" }, aside));
}

function Alert(params) {
    return React__default.createElement(GroupRoot, { className: classNames("Alert", "Alert-" + params.type, params.className) },
        React__default.createElement(Header, { title: params.title, subtitle: params.children }));
}

var Ripple = React__default.memo(function Ripple(_a) {
    var onInit = _a.onInit;
    var ref = useRef();
    useEffect(function () {
        onInit({
            onClick: function (event) {
                var rippleTarget = event.currentTarget;
                var rect = rippleTarget.getBoundingClientRect();
                console.log(event);
                var diameter = Math.max(rippleTarget.clientWidth, rippleTarget.clientHeight);
                var radius = diameter / 2;
                var rippleSpan = ref.current;
                if (rippleSpan == undefined)
                    return;
                rippleSpan.className = "Ripple-Hidden";
                rippleSpan.style.height = rippleSpan.style.width = rippleSpan.style.left = rippleSpan.style.top = undefined;
                setTimeout(function () {
                    rippleSpan.className = "Ripple";
                    rippleSpan.style.width = rippleSpan.style.height = "".concat(diameter, "px");
                    rippleSpan.style.left = "".concat(event.clientX - rect.left - radius, "px");
                    rippleSpan.style.top = "".concat(event.clientY - rect.top - radius, "px");
                }, 10);
            }
        });
    });
    return React__default.createElement("span", { ref: ref });
});

function Cell(props) {
    var before = props.before, after = props.after, titleDescription = props.titleDescription, description = props.description, onClick = props.onClick, params = __rest(props, ["before", "after", "titleDescription", "description", "onClick"]);
    var rippleStruct = undefined;
    return React__default.createElement("div", __assign({}, params, { className: classNames("Cell", onClick && "Cell-Selectable", params.className), onClick: function (event) {
            var _a;
            (_a = rippleStruct === null || rippleStruct === void 0 ? void 0 : rippleStruct.onClick) === null || _a === void 0 ? void 0 : _a.call(rippleStruct, event);
            if (onClick != null) {
                onClick(event);
            }
        } }),
        React__default.createElement(Ripple, { onInit: function (struct) {
                rippleStruct = struct;
            } }),
        before && React__default.createElement("i", { className: "Cell-before" }, before),
        React__default.createElement("div", { className: "Cell-inner" },
            React__default.createElement("div", { className: "Cell-Title-Container" },
                params.children && React__default.createElement("div", { className: "Cell-Title" }, params.children),
                titleDescription && React__default.createElement("div", { className: "Cell-Title-Description" }, titleDescription)),
            description && React__default.createElement("div", { className: "Cell-Description" }, description)),
        after && React__default.createElement("div", { className: "Cell-after" }, after));
}

function Group(props) {
    var header = props.header, params = __rest(props, ["header"]);
    return React__default.createElement(GroupRoot, null,
        header && React__default.createElement("div", { className: "Group-Header" }, header),
        React__default.createElement(Div, __assign({}, params)));
}

function Toolbar(params) {
    var title = params.title, before = params.before, children = params.children, className = params.className, otherParams = __rest(params, ["title", "before", "children", "className"]);
    return React__default.createElement("div", __assign({}, otherParams, { className: classNames("Toolbar", className) }),
        before && React__default.createElement("span", { className: "Toolbar-Before" }, params.before),
        title && React__default.createElement("span", { className: "Toolbar-Title" }, title),
        children && React__default.createElement("div", { className: "Toolbar-Actions" }, children));
}

function HorizontalList(props) {
    return React__default.createElement("div", __assign({}, props, { className: classNames("HorizontalList", props.className) }),
        React__default.createElement("div", { className: "HorizontalList--in" }, props.children));
}

function Tabs(params) {
    return React__default.createElement("div", { className: classNames("Tabs", params.className) },
        React__default.createElement(HorizontalList, null, params.children));
}

function TabsItem(params) {
    var selected = params.selected, onClick = params.onClick, children = params.children, otherParams = __rest(params, ["selected", "onClick", "children"]);
    var rippleStruct = undefined;
    return React__default.createElement("div", __assign({}, otherParams, { className: "TabsItem " + (selected ? "TabsItem-Active" : ""), onClick: function (event) {
            var _a;
            (_a = rippleStruct === null || rippleStruct === void 0 ? void 0 : rippleStruct.onClick) === null || _a === void 0 ? void 0 : _a.call(rippleStruct, event);
            if (onClick != null) {
                onClick(event);
            }
        } }),
        React__default.createElement(Ripple, { onInit: function (struct) {
                rippleStruct = struct;
            } }),
        React__default.createElement("div", { className: "TabsItem-Title" }, children),
        selected && React__default.createElement("div", { className: "TabsItem-Indicator" }));
}

function MiniCell(props) {
    var before = props.before, params = __rest(props, ["before"]);
    return React__default.createElement("div", __assign({}, params, { className: classNames("MiniCell", params.onClick && "MiniCell-Selectable", params.className) }),
        before && React__default.createElement("i", { className: "MiniCell-before" }, before),
        params.children && React__default.createElement("div", { className: "MiniCell-Title" }, params.children));
}

function AdaptiveList(params) {
    return React__default.createElement("div", __assign({}, params, { className: classNames("AdaptiveList", params.className) }));
}

function FormLayout(props) {
    return React__default.createElement("div", __assign({ className: classNames("FormLayout", props.className) }, props));
}

function IconButton(params) {
    var onClick = params.onClick, children = params.children, otherParams = __rest(params, ["onClick", "children"]);
    var rippleStruct = undefined;
    return React__default.createElement("div", __assign({}, otherParams, { className: classNames("IconButton", params.className), onClick: function (event) {
            var _a;
            (_a = rippleStruct === null || rippleStruct === void 0 ? void 0 : rippleStruct.onClick) === null || _a === void 0 ? void 0 : _a.call(rippleStruct, event);
            if (onClick != null) {
                onClick(event);
            }
        } }),
        React__default.createElement(Ripple, { onInit: function (struct) {
                rippleStruct = struct;
            } }),
        children);
}

function Link(params) {
    return React__default.createElement("a", __assign({}, params, { className: classNames("Link", params.className) }));
}

function Button(props) {
    var _a = props.appearance, appearance = _a === void 0 ? "accent" : _a, _b = props.mode, mode = _b === void 0 ? "primary" : _b, before = props.before, after = props.after, stretched = props.stretched, onClick = props.onClick, otherProps = __rest(props, ["appearance", "mode", "before", "after", "stretched", "onClick"]);
    var rippleStruct = undefined;
    return React__default.createElement("button", __assign({}, otherProps, { className: classNames("Button", "Card", "Button--" + appearance, "Button--" + mode, stretched && "Button--stretched", otherProps.className), onClick: function (event) {
            var _a;
            (_a = rippleStruct === null || rippleStruct === void 0 ? void 0 : rippleStruct.onClick) === null || _a === void 0 ? void 0 : _a.call(rippleStruct, event);
            if (onClick != null) {
                onClick(event);
            }
        } }),
        React__default.createElement(Ripple, { onInit: function (struct) {
                rippleStruct = struct;
            } }),
        before && React__default.createElement("div", { className: "Button-Before" }, before),
        React__default.createElement("div", { className: "Button-Text" }, otherProps.children),
        after && React__default.createElement("div", null, after));
}

var _path$s;

function _extends$v() { _extends$v = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$v.apply(this, arguments); }

var SvgSpinner = function SvgSpinner(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$v({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$s || (_path$s = /*#__PURE__*/React.createElement("path", {
    d: "M19.2 12C19.6418 12 20.0041 12.3591 19.96 12.7987C19.8085 14.3094 19.2293 15.7518 18.2825 16.9528C17.1701 18.3639 15.6149 19.3595 13.8676 19.779C12.1203 20.1984 10.2826 20.0175 8.65072 19.2651C7.01883 18.5128 5.68775 17.233 4.87195 15.6319C4.05615 14.0308 3.80315 12.2017 4.15372 10.4393C4.50429 8.67686 5.438 7.08378 6.80441 5.91675C8.17083 4.74973 9.89035 4.07672 11.6859 4.00617C13.214 3.94613 14.7214 4.32539 16.0326 5.09073C16.4142 5.31345 16.4918 5.81763 16.2321 6.17508V6.17508C15.9724 6.53252 15.474 6.60678 15.0869 6.39367C14.0711 5.83433 12.9175 5.55901 11.7487 5.60493C10.3123 5.66137 8.93666 6.19978 7.84353 7.1334C6.7504 8.06702 6.00343 9.34148 5.72297 10.7514C5.44252 12.1614 5.64492 13.6247 6.29756 14.9055C6.9502 16.1864 8.01507 17.2103 9.32058 17.8121C10.6261 18.414 12.0962 18.5588 13.4941 18.2232C14.8919 17.8876 16.136 17.0911 17.026 15.9622C17.7501 15.0437 18.2055 13.9485 18.3501 12.7979C18.4052 12.3596 18.7582 12 19.2 12V12Z",
    fill: "currentColor"
  })));
};

function Spinner(params) {
    var _a = params.size, size = _a === void 0 ? "regular" : _a, props = __rest(params, ["size"]);
    return React__default.createElement("div", __assign({}, props, { className: classNames("Spinner", "Spinner-" + size, params.className) }),
        React__default.createElement(SvgSpinner, null));
}

function PanelSpinner(props) {
    return React__default.createElement("div", __assign({}, props, { className: "PanelSpinner" }),
        React__default.createElement(Spinner, null));
}

function CellButton(props) {
    var _a = props.appearance, appearance = _a === void 0 ? "accent" : _a, before = props.before, after = props.after, otherProps = __rest(props, ["appearance", "before", "after"]);
    return React__default.createElement("button", __assign({}, otherProps, { className: classNames("CellButton", "CellButton--" + appearance, otherProps.className) }),
        before && React__default.createElement("div", { className: "CellButton-Before" }, before),
        React__default.createElement("div", { className: "CellButton-Text" }, otherProps.children),
        after && React__default.createElement("div", null, after));
}

function ViewPager(props) {
    var panels = !Array.isArray(props.children) ? [props.children] :
        props.children;
    return React__default.createElement("div", { className: "ViewPager" }, panels);
}

function NavigationListItem(props) {
    var before = props.before, after = props.after, titleDescription = props.titleDescription, description = props.description, onClick = props.onClick, params = __rest(props, ["before", "after", "titleDescription", "description", "onClick"]);
    var rippleStruct = undefined;
    return React__default.createElement("div", __assign({}, params, { className: classNames("NavigationListItem", onClick && "NavigationListItem-Selectable", params.className), onClick: function (event) {
            var _a;
            (_a = rippleStruct === null || rippleStruct === void 0 ? void 0 : rippleStruct.onClick) === null || _a === void 0 ? void 0 : _a.call(rippleStruct, event);
            if (onClick != null) {
                onClick(event);
            }
        } }),
        React__default.createElement(Ripple, { onInit: function (struct) {
                rippleStruct = struct;
            } }),
        before && React__default.createElement("i", { className: "NavigationListItem-before" }, before),
        React__default.createElement("div", { className: "NavigationListItem-inner" },
            React__default.createElement("div", { className: "NavigationListItem-Title-Container" },
                params.children && React__default.createElement("div", { className: "NavigationListItem-Title" }, params.children),
                titleDescription && React__default.createElement("div", { className: "NavigationListItem-Title-Description" }, titleDescription)),
            description && React__default.createElement("div", { className: "NavigationListItem-Description" }, description)),
        after && React__default.createElement("div", { className: "NavigationListItem-after" }, after));
}

function ModalRoot(props) {
    var dismiss = props.dismiss, className = props.className, children = props.children;
    return React__default.createElement("div", { className: classNames("ModalRoot", className), onClick: function () { return dismiss(undefined); } }, children);
}

function Dialog(props) {
    var dismiss = props.dismiss, className = props.className, children = props.children;
    return React__default.createElement(ModalRoot, { dismiss: dismiss, className: classNames("Dialog", className) },
        React__default.createElement(Card, null, children));
}

function NavigationBottomItem(props) {
    var icon = props.icon, selected = props.selected, params = __rest(props, ["icon", "selected"]);
    return React__default.createElement("div", __assign({}, params, { className: classNames("NavigationBottomItem", params.onClick && "NavigationBottomItem-Selectable", params.className) }),
        React__default.createElement("div", { "data-selected": selected, className: "NavigationBottomItem-Icon" }, icon));
}

function ContextMenu(props) {
    var _a = useState({ x: 0, y: 0 }), anchorPoint = _a[0], setAnchorPoint = _a[1];
    var _b = useState(false), show = _b[0], setShow = _b[1];
    var handleContextMenu = useCallback(function (event) {
        event.preventDefault();
        setAnchorPoint({ x: event.targetX + event.target.width, y: event.targetY + event.target.height });
        setShow(true);
    }, [setAnchorPoint, setShow]);
    return React__default.createElement(React__default.Fragment, null,
        React__default.createElement("div", { onClick: handleContextMenu }, props.children),
        show && React__default.createElement(Card, { style: {
                position: "absolute",
                marginTop: anchorPoint.y,
                marginLeft: anchorPoint.x,
                border: "black 1px solid"
            } }, props.menu({
            dismiss: function () { return setShow(false); }
        })));
}

function FloatingActionButton(props) {
    var _a = props.appearance, appearance = _a === void 0 ? "accent" : _a; props.expanded; var _c = props.label, label = _c === void 0 ? "Action" : _c, icon = props.icon, stretched = props.stretched, _d = props.size, size = _d === void 0 ? 64 : _d, onClick = props.onClick, otherProps = __rest(props, ["appearance", "expanded", "label", "icon", "stretched", "size", "onClick"]);
    var rippleStruct = undefined;
    return React__default.createElement("button", __assign({}, otherProps, { className: classNames("FloatingActionButton", "Card", "FloatingActionButton--" + appearance, stretched && "FloatingActionButton--stretched", otherProps.className), style: {
            height: size,
            width: size,
        }, onClick: function (event) {
            var _a;
            (_a = rippleStruct === null || rippleStruct === void 0 ? void 0 : rippleStruct.onClick) === null || _a === void 0 ? void 0 : _a.call(rippleStruct, event);
            if (onClick != null) {
                onClick(event);
            }
        }, "aria-label": label }),
        React__default.createElement(Ripple, { onInit: function (struct) {
                rippleStruct = struct;
            } }),
        React__default.createElement("div", { className: "FloatingActionButton-Icon" }, icon));
}

function Switch(params) {
    var thumb = useRef();
    var checkbox = useRef();
    var checked = false;
    return React__default.createElement("div", { className: "Switch", onClick: function () {
            checked = !checked;
            checkbox.current.checked = checked;
        }, onMouseDown: function () {
            thumb.current.style.height = thumb.current.style.width = "calc(var(--height) - var(--border-width) * 2)";
        }, onMouseUp: function () {
            thumb.current.style.height = thumb.current.style.width = undefined;
        }, onMouseOutCapture: function () {
            thumb.current.style.height = thumb.current.style.width = undefined;
        }, onMouseLeave: function () {
            thumb.current.style.height = thumb.current.style.width = undefined;
        } },
        React__default.createElement("div", { className: "Switch-Thumb", ref: thumb }),
        React__default.createElement("input", { type: "checkbox", ref: checkbox, onChange: function (event) {
                checked = event.currentTarget.checked;
                var parent = event.currentTarget.parentElement;
                parent.setAttribute("checked", String(event.currentTarget.checked));
                thumb.current.setAttribute("checked", String(event.currentTarget.checked));
                if (checked) {
                    thumb.current.style.height = thumb.current.style.width = "24px";
                    thumb.current.style.transform = "translateX(calc(75%))";
                }
                else {
                    thumb.current.style.height = thumb.current.style.width = "16px";
                    thumb.current.style.transform = "translateX(0)";
                }
                if (params.onChecked)
                    params.onChecked(event);
            } }));
}

var _rect$4, _rect2$1;

function _extends$u() { _extends$u = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$u.apply(this, arguments); }

var SvgAddIcon = function SvgAddIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$u({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect$4 || (_rect$4 = /*#__PURE__*/React.createElement("rect", {
    x: 11.25,
    y: 2,
    width: 1.5,
    height: 20,
    rx: 0.75,
    fill: "currentColor"
  })), _rect2$1 || (_rect2$1 = /*#__PURE__*/React.createElement("rect", {
    x: 2,
    y: 12.5,
    width: 1.5,
    height: 20,
    rx: 0.75,
    transform: "rotate(-90 2 12.5)",
    fill: "currentColor"
  })));
};

var _path$r;

function _extends$t() { _extends$t = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$t.apply(this, arguments); }

var SvgAttachIcon = function SvgAttachIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$t({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$r || (_path$r = /*#__PURE__*/React.createElement("path", {
    d: "M17.5 17V6.75C17.5 6.33579 17.1642 6 16.75 6C16.3358 6 16 6.33579 16 6.75V17C16 18.933 14.433 20.5 12.5 20.5C10.567 20.5 9 18.933 9 17V5.25C9 4.00736 10.0074 3 11.25 3C12.4926 3 13.5 4.00736 13.5 5.25V15.5C13.5 16.0523 13.0523 16.5 12.5 16.5C11.9477 16.5 11.5 16.0523 11.5 15.5V6.75C11.5 6.33579 11.1642 6 10.75 6C10.3358 6 10 6.33579 10 6.75V15.5C10 16.8807 11.1193 18 12.5 18C13.8807 18 15 16.8807 15 15.5V5.25C15 3.17893 13.3211 1.5 11.25 1.5C9.17893 1.5 7.5 3.17893 7.5 5.25V17C7.5 19.7614 9.73858 22 12.5 22C15.2614 22 17.5 19.7614 17.5 17Z",
    fill: "currentColor"
  })));
};

var _path$q, _path2$e;

function _extends$s() { _extends$s = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$s.apply(this, arguments); }

var SvgBackBoldIcon = function SvgBackBoldIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$s({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$q || (_path$q = /*#__PURE__*/React.createElement("path", {
    d: "M5.14316 11.1069L11.4028 6.21659C11.5783 6.07947 11.806 6.02812 12.0234 6.07664C12.6437 6.2151 12.8165 7.01702 12.3083 7.3987L6.18182 12L12.3083 16.6013C12.8165 16.9829 12.6437 17.7849 12.0234 17.9233C11.806 17.9719 11.5783 17.9205 11.4027 17.7834L5.14316 12.8931C4.56236 12.4394 4.56235 11.5607 5.14316 11.1069Z",
    fill: "currentColor"
  })), _path2$e || (_path2$e = /*#__PURE__*/React.createElement("path", {
    d: "M19.25 12.75H5.81665C5.40244 12.75 5.06665 12.4142 5.06665 12C5.06665 11.5858 5.40244 11.25 5.81665 11.25H19.25C19.6642 11.25 20 11.5858 20 12C20 12.4142 19.6642 12.75 19.25 12.75Z",
    fill: "currentColor"
  })));
};

var _path$p, _path2$d;

function _extends$r() { _extends$r = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$r.apply(this, arguments); }

var SvgBotIcon = function SvgBotIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$r({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$p || (_path$p = /*#__PURE__*/React.createElement("path", {
    d: "M17 7H7C4.23858 7 2 9.23858 2 12C2 14.7614 4.23858 17 7 17H17C19.7614 17 22 14.7614 22 12C22 9.23858 19.7614 7 17 7Z",
    stroke: "currentColor"
  })), _path2$d || (_path2$d = /*#__PURE__*/React.createElement("path", {
    d: "M6.66211 14V9.73438H8.15625C8.67383 9.73438 9.06641 9.83398 9.33398 10.0332C9.60156 10.2305 9.73535 10.5205 9.73535 10.9033C9.73535 11.1123 9.68164 11.2969 9.57422 11.457C9.4668 11.6152 9.31738 11.7314 9.12598 11.8057C9.34473 11.8604 9.5166 11.9707 9.6416 12.1367C9.76855 12.3027 9.83203 12.5059 9.83203 12.7461C9.83203 13.1562 9.70117 13.4668 9.43945 13.6777C9.17773 13.8887 8.80469 13.9961 8.32031 14H6.66211ZM7.54102 12.1426V13.2939H8.29395C8.50098 13.2939 8.66211 13.2451 8.77734 13.1475C8.89453 13.0479 8.95312 12.9111 8.95312 12.7373C8.95312 12.3467 8.75098 12.1484 8.34668 12.1426H7.54102ZM7.54102 11.5215H8.19141C8.63477 11.5137 8.85645 11.3369 8.85645 10.9912C8.85645 10.7979 8.7998 10.6592 8.68652 10.5752C8.5752 10.4893 8.39844 10.4463 8.15625 10.4463H7.54102V11.5215ZM13.998 11.9639C13.998 12.3838 13.9238 12.752 13.7754 13.0684C13.627 13.3848 13.4141 13.6289 13.1367 13.8008C12.8613 13.9727 12.5449 14.0586 12.1875 14.0586C11.834 14.0586 11.5186 13.9736 11.2412 13.8037C10.9639 13.6338 10.749 13.3916 10.5967 13.0771C10.4443 12.7607 10.3672 12.3975 10.3652 11.9873V11.7764C10.3652 11.3564 10.4404 10.9873 10.5908 10.6689C10.7432 10.3486 10.957 10.1035 11.2324 9.93359C11.5098 9.76172 11.8262 9.67578 12.1816 9.67578C12.5371 9.67578 12.8525 9.76172 13.1279 9.93359C13.4053 10.1035 13.6191 10.3486 13.7695 10.6689C13.9219 10.9873 13.998 11.3555 13.998 11.7734V11.9639ZM13.1074 11.7705C13.1074 11.3232 13.0273 10.9834 12.8672 10.751C12.707 10.5186 12.4785 10.4023 12.1816 10.4023C11.8867 10.4023 11.6592 10.5176 11.499 10.748C11.3389 10.9766 11.2578 11.3125 11.2559 11.7559V11.9639C11.2559 12.3994 11.3359 12.7373 11.4961 12.9775C11.6562 13.2178 11.8867 13.3379 12.1875 13.3379C12.4824 13.3379 12.709 13.2227 12.8672 12.9922C13.0254 12.7598 13.1055 12.4219 13.1074 11.9785V11.7705ZM17.5957 10.4463H16.2891V14H15.4102V10.4463H14.1211V9.73438H17.5957V10.4463Z",
    fill: "currentColor"
  })));
};

var _circle$2, _circle2$1, _path$o;

function _extends$q() { _extends$q = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$q.apply(this, arguments); }

var SvgCoinIcon = function SvgCoinIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$q({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$2 || (_circle$2 = /*#__PURE__*/React.createElement("circle", {
    cx: 12,
    cy: 12,
    r: 8,
    fill: "#606060"
  })), _circle2$1 || (_circle2$1 = /*#__PURE__*/React.createElement("circle", {
    cx: 12,
    cy: 12,
    r: 7,
    fill: "#989898"
  })), _path$o || (_path$o = /*#__PURE__*/React.createElement("path", {
    d: "M9.57789 8.21774L15.05 9.68401C15.6553 9.8462 16.0146 10.4684 15.8524 11.0737C15.7628 11.4081 15.5255 11.6832 15.2079 11.821L12.6945 12.9112C12.0071 13.2093 12.0808 14.2073 12.8046 14.4012L14.8577 14.9513C15.3065 15.0716 15.5729 15.5329 15.4526 15.9817C15.3323 16.4305 14.871 16.6969 14.4222 16.5766L8.63555 15.0261C8.0197 14.8611 7.65423 14.228 7.81925 13.6122C7.90606 13.2882 8.12947 13.018 8.43136 12.8719L11.0077 11.6248C11.5955 11.3402 11.5138 10.4784 10.8831 10.3094L9.1424 9.84301C8.6936 9.72276 8.42726 9.26144 8.54751 8.81263C8.66777 8.36383 9.12909 8.09749 9.57789 8.21774Z",
    fill: "#606060"
  })));
};

var _path$n;

function _extends$p() { _extends$p = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$p.apply(this, arguments); }

var SvgCommentsIcon = function SvgCommentsIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$p({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$n || (_path$n = /*#__PURE__*/React.createElement("path", {
    d: "M20 5H4C3.44772 5 3 5.44771 3 6V15C3 15.5523 3.44772 16 4 16H17.7278C18.0024 16 18.2649 16.1129 18.4537 16.3123L21 19V6C21 5.44772 20.5523 5 20 5Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$m, _path2$c;

function _extends$o() { _extends$o = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$o.apply(this, arguments); }

var SvgDebugIcon = function SvgDebugIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$o({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$m || (_path$m = /*#__PURE__*/React.createElement("path", {
    d: "M20.3493 16.0287L13.7483 4.14697C12.9863 2.77535 11.0137 2.77535 10.2517 4.14697L3.65071 16.0287C2.91012 17.3618 3.87406 19 5.39903 19H18.601C20.1259 19 21.0899 17.3618 20.3493 16.0287Z",
    stroke: "currentColor"
  })), _path2$c || (_path2$c = /*#__PURE__*/React.createElement("path", {
    d: "M8.08594 17.0001H7.16602L7.17188 16.3673H8.08594C8.33398 16.3673 8.54199 16.3126 8.70996 16.2032C8.87793 16.0919 9.00488 15.9327 9.09082 15.7257C9.17676 15.5167 9.21973 15.2667 9.21973 14.9757V14.756C9.21973 14.5314 9.19531 14.3331 9.14648 14.1613C9.09766 13.9894 9.02539 13.8448 8.92969 13.7277C8.83594 13.6105 8.71973 13.5216 8.58105 13.4611C8.44238 13.4005 8.2832 13.3702 8.10352 13.3702H7.14844V12.7345H8.10352C8.38867 12.7345 8.64844 12.7823 8.88281 12.8781C9.11914 12.9738 9.32324 13.1115 9.49512 13.2911C9.66895 13.4689 9.80176 13.6818 9.89355 13.9298C9.9873 14.1779 10.0342 14.4552 10.0342 14.7618V14.9757C10.0342 15.2804 9.9873 15.5577 9.89355 15.8077C9.80176 16.0558 9.66895 16.2687 9.49512 16.4464C9.32324 16.6241 9.11816 16.7609 8.87988 16.8566C8.6416 16.9523 8.37695 17.0001 8.08594 17.0001ZM7.61719 12.7345V17.0001H6.81152V12.7345H7.61719ZM13.5469 16.3673V17.0001H11.2793V16.3673H13.5469ZM11.5254 12.7345V17.0001H10.7197V12.7345H11.5254ZM13.251 14.4952V15.1134H11.2793V14.4952H13.251ZM13.5381 12.7345V13.3702H11.2793V12.7345H13.5381ZM15.6064 16.1652L16.6699 12.7345H17.5635L16.0576 17.0001H15.4629L15.6064 16.1652ZM14.625 12.7345L15.6826 16.1652L15.835 17.0001H15.2344L13.7344 12.7345H14.625Z",
    fill: "currentColor"
  })));
};

var _path$l;

function _extends$n() { _extends$n = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$n.apply(this, arguments); }

var SvgDeleteIcon = function SvgDeleteIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$n({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$l || (_path$l = /*#__PURE__*/React.createElement("path", {
    d: "M17.7192 5H6.28078C5.63021 5 5.15285 5.61139 5.31063 6.24253L8.31063 18.2425C8.42193 18.6877 8.82191 19 9.28078 19H14.7192C15.1781 19 15.5781 18.6877 15.6894 18.2425L18.6894 6.24254C18.8472 5.61139 18.3698 5 17.7192 5Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$k;

function _extends$m() { _extends$m = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$m.apply(this, arguments); }

var SvgDialogsIcon = function SvgDialogsIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$m({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$k || (_path$k = /*#__PURE__*/React.createElement("path", {
    d: "M3 15.2857V7C3 6.44772 3.44772 6 4 6H20C20.5523 6 21 6.44772 21 7V16.2857V18L19.1575 16.5085C18.9795 16.3643 18.7574 16.2857 18.5283 16.2857H4C3.44772 16.2857 3 15.838 3 15.2857Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$j;

function _extends$l() { _extends$l = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$l.apply(this, arguments); }

var SvgDoneIcon = function SvgDoneIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$l({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$j || (_path$j = /*#__PURE__*/React.createElement("path", {
    d: "M20 7L10.25 17.5L5 11.5",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$i, _path2$b, _path3$8;

function _extends$k() { _extends$k = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$k.apply(this, arguments); }

var SvgDownloadIcon = function SvgDownloadIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$k({
    width: 24,
    height: 25,
    viewBox: "0 0 24 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$i || (_path$i = /*#__PURE__*/React.createElement("path", {
    d: "M11.1814 17.2855L6.69855 11.5475C6.57284 11.3866 6.52578 11.1779 6.57026 10.9786C6.69718 10.41 7.43227 10.2516 7.78214 10.7174L12 16.3334L16.2178 10.7174C16.5677 10.2516 17.3028 10.41 17.4297 10.9786C17.4742 11.1779 17.4272 11.3866 17.3014 11.5475L12.8187 17.2855C12.4028 17.8179 11.5973 17.8179 11.1814 17.2855Z",
    fill: "currentColor"
  })), _path2$b || (_path2$b = /*#__PURE__*/React.createElement("path", {
    d: "M12.6875 4.3542L12.6875 16.6681C12.6875 17.0478 12.3797 17.3556 12 17.3556C11.6203 17.3556 11.3125 17.0478 11.3125 16.6681L11.3125 4.3542C11.3125 3.9745 11.6203 3.6667 12 3.6667C12.3797 3.6667 12.6875 3.9745 12.6875 4.3542Z",
    fill: "currentColor"
  })), _path3$8 || (_path3$8 = /*#__PURE__*/React.createElement("path", {
    d: "M20 22H4C3.44772 22 3 21.5523 3 21V18.75C3 18.3358 3.33579 18 3.75 18C4.16421 18 4.5 18.3358 4.5 18.75V19.4378C4.5 19.9901 4.94772 20.4378 5.5 20.4378H18.5C19.0523 20.4378 19.5 19.9901 19.5 19.4378V18.75C19.5 18.3358 19.8358 18 20.25 18C20.6642 18 21 18.3358 21 18.75V21C21 21.5523 20.5523 22 20 22Z",
    fill: "currentColor"
  })));
};

var _path$h, _path2$a, _path3$7, _path4$2, _path5$2, _path6$2;

function _extends$j() { _extends$j = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$j.apply(this, arguments); }

var SvgFeedIcon = function SvgFeedIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$j({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$h || (_path$h = /*#__PURE__*/React.createElement("path", {
    d: "M4 6V18C4 18.5523 4.44772 19 5 19H19C19.5523 19 20 18.5523 20 18V6C20 5.44772 19.5523 5 19 5H5C4.44772 5 4 5.44772 4 6Z",
    stroke: "currentColor",
    strokeWidth: 1.5
  })), _path2$a || (_path2$a = /*#__PURE__*/React.createElement("path", {
    d: "M7 7C7.55228 7 8 7.44772 8 8C8 8.55228 7.55228 9 7 9C6.44772 9 6 8.55228 6 8C6 7.44772 6.44772 7 7 7Z",
    fill: "currentColor"
  })), _path3$7 || (_path3$7 = /*#__PURE__*/React.createElement("path", {
    d: "M9.5 7H13.5M8 8V8C8 8.55228 7.55228 9 7 9V9C6.44772 9 6 8.55228 6 8V8C6 7.44772 6.44772 7 7 7V7C7.55228 7 8 7.44772 8 8Z",
    stroke: "currentColor"
  })), _path4$2 || (_path4$2 = /*#__PURE__*/React.createElement("path", {
    d: "M9.5 8.5H16",
    stroke: "currentColor",
    strokeWidth: 0.5
  })), _path5$2 || (_path5$2 = /*#__PURE__*/React.createElement("path", {
    d: "M6 10.5H16",
    stroke: "currentColor",
    strokeWidth: 0.5
  })), _path6$2 || (_path6$2 = /*#__PURE__*/React.createElement("path", {
    d: "M17 12H7C6.44772 12 6 12.4477 6 13V18C6 18.5523 6.44772 19 7 19H17C17.5523 19 18 18.5523 18 18V13C18 12.4477 17.5523 12 17 12Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 0.5
  })));
};

var _path$g, _rect$3, _path2$9, _path3$6, _g;

function _extends$i() { _extends$i = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$i.apply(this, arguments); }

var SvgFollowersIcon = function SvgFollowersIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$i({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$g || (_path$g = /*#__PURE__*/React.createElement("path", {
    d: "M10.5 13.9996C4.81162 13.9996 3.4376 17.8825 3.1057 19.7584C3.00948 20.3022 3.44772 20.7496 4 20.7496H17C17.5523 20.7496 17.9905 20.3022 17.8943 19.7584C17.5624 17.8825 16.1884 13.9996 10.5 13.9996Z",
    stroke: "currentColor",
    strokeWidth: 1.5
  })), _rect$3 || (_rect$3 = /*#__PURE__*/React.createElement("rect", {
    x: 7.5,
    y: 5.75,
    width: 6,
    height: 6,
    rx: 3,
    stroke: "currentColor",
    strokeWidth: 1.5
  })), _path2$9 || (_path2$9 = /*#__PURE__*/React.createElement("path", {
    d: "M10.2563 14C10.6724 13.7599 11.1416 13.5523 11.6707 13.3894C12.4694 13.1436 13.4047 12.9996 14.5 12.9996C20.1884 12.9996 21.5624 16.8825 21.8943 18.7584C21.9905 19.3022 21.5523 19.7496 21 19.7496H18",
    stroke: "currentColor",
    strokeWidth: 1.5
  })), /*#__PURE__*/React.createElement("mask", {
    id: "mask0_73_282",
    style: {
      maskType: "alpha"
    },
    maskUnits: "userSpaceOnUse",
    x: 11,
    y: 4,
    width: 8,
    height: 8
  }, _path3$6 || (_path3$6 = /*#__PURE__*/React.createElement("path", {
    d: "M13.0303 5.96967L12.9918 5.93115L12.9481 5.8986L12.6105 5.64699C13.1553 5.09264 13.9129 4.75 14.7501 4.75C16.4069 4.75 17.7501 6.09315 17.7501 7.75C17.7501 9.40685 16.4069 10.75 14.7501 10.75C14.3947 10.75 14.0547 10.6885 13.7393 10.5757L14.2073 9.24959L14.25 9.12846V9V7.5V7.18934L14.0303 6.96967L13.0303 5.96967Z",
    stroke: "currentColor",
    strokeWidth: 1.5
  }))), _g || (_g = /*#__PURE__*/React.createElement("g", {
    mask: "url(#mask0_73_282)"
  }, /*#__PURE__*/React.createElement("rect", {
    x: 11.75,
    y: 4.75,
    width: 6,
    height: 6,
    rx: 3,
    stroke: "currentColor",
    strokeWidth: 1.5
  }))));
};

var _circle$1, _rect$2, _circle2;

function _extends$h() { _extends$h = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$h.apply(this, arguments); }

var SvgInfoIcon = function SvgInfoIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$h({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _circle$1 || (_circle$1 = /*#__PURE__*/React.createElement("circle", {
    cx: 12,
    cy: 6.75,
    r: 0.75,
    fill: "currentColor"
  })), _rect$2 || (_rect$2 = /*#__PURE__*/React.createElement("rect", {
    x: 11.25,
    y: 9,
    width: 1.5,
    height: 10,
    rx: 0.75,
    fill: "currentColor"
  })), _circle2 || (_circle2 = /*#__PURE__*/React.createElement("circle", {
    cx: 12,
    cy: 12,
    r: 9.25,
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$f, _rect$1;

function _extends$g() { _extends$g = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$g.apply(this, arguments); }

var SvgLikeIcon = function SvgLikeIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$g({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$f || (_path$f = /*#__PURE__*/React.createElement("path", {
    d: "M11.1653 4.08264V7.09694C11.1653 7.67266 11.4223 8.21831 11.8661 8.58497C12.2121 8.87072 12.6467 9.02703 13.0954 9.02703H19C20.6569 9.02703 22 10.3702 22 12.027V17.6757V19C22 20.6569 20.6569 22 19 22H10C8.34315 22 7 20.6569 7 19V8.00601V4.08265C7 2.93243 7.93243 2 9.08265 2C10.2329 2 11.1653 2.93243 11.1653 4.08264Z",
    fill: "currentColor"
  })), _rect$1 || (_rect$1 = /*#__PURE__*/React.createElement("rect", {
    x: 2,
    y: 8,
    width: 3,
    height: 14,
    rx: 1.5,
    fill: "currentColor"
  })));
};

var _path$e, _path2$8, _path3$5;

function _extends$f() { _extends$f = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$f.apply(this, arguments); }

var SvgLogoutIcon = function SvgLogoutIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$f({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$e || (_path$e = /*#__PURE__*/React.createElement("path", {
    d: "M7.5625 3H15.1562C15.6222 3 16 3.37776 16 3.84375C16 4.30974 15.6222 4.6875 15.1563 4.6875H8.01136C6.69969 4.6875 5.63636 5.75082 5.63636 7.0625V16.9375C5.63636 18.2492 6.69969 19.3125 8.01136 19.3125H15.1562C15.6222 19.3125 16 19.6903 16 20.1562C16 20.6222 15.6222 21 15.1562 21H7.5625C5.59499 21 4 19.405 4 17.4375V6.5625C4 4.59499 5.59499 3 7.5625 3Z",
    fill: "currentColor"
  })), _path2$8 || (_path2$8 = /*#__PURE__*/React.createElement("path", {
    d: "M20.5713 12.5954L16.3982 15.8556C16.2812 15.947 16.1294 15.9813 15.9845 15.9489C15.5709 15.8566 15.4557 15.322 15.7945 15.0675L19.8788 12L15.7945 8.93249C15.4557 8.67803 15.5709 8.14342 15.9845 8.0511C16.1294 8.01875 16.2812 8.05298 16.3982 8.1444L20.5713 11.4046C20.9585 11.7071 20.9585 12.2929 20.5713 12.5954Z",
    fill: "currentColor"
  })), _path3$5 || (_path3$5 = /*#__PURE__*/React.createElement("path", {
    d: "M11.1666 11.5L20.1222 11.5C20.3983 11.5 20.6222 11.7239 20.6222 12C20.6222 12.2761 20.3983 12.5 20.1222 12.5L11.1666 12.5C10.8905 12.5 10.6666 12.2761 10.6666 12C10.6666 11.7239 10.8905 11.5 11.1666 11.5Z",
    fill: "currentColor"
  })));
};

var _path$d;

function _extends$e() { _extends$e = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$e.apply(this, arguments); }

var SvgMailIcon = function SvgMailIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$e({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$d || (_path$d = /*#__PURE__*/React.createElement("path", {
    d: "M3 5V20.619C3 21.0866 3.58473 21.2983 3.88411 20.9391L7.40031 16.7196C7.78029 16.2636 8.34319 16 8.93675 16H19C20.1046 16 21 15.1046 21 14V5C21 3.89543 20.1046 3 19 3H5C3.89543 3 3 3.89543 3 5Z",
    fill: "currentColor"
  })));
};

var _path$c, _path2$7, _path3$4;

function _extends$d() { _extends$d = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$d.apply(this, arguments); }

var SvgMenuIcon = function SvgMenuIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$d({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$c || (_path$c = /*#__PURE__*/React.createElement("path", {
    d: "M3 6C3 5.44772 3.44772 5 4 5H20C20.5523 5 21 5.44772 21 6C21 6.55228 20.5523 7 20 7H4C3.44772 7 3 6.55228 3 6Z",
    fill: "currentColor"
  })), _path2$7 || (_path2$7 = /*#__PURE__*/React.createElement("path", {
    d: "M3 12C3 11.4477 3.44772 11 4 11H20C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H4C3.44772 13 3 12.5523 3 12Z",
    fill: "currentColor"
  })), _path3$4 || (_path3$4 = /*#__PURE__*/React.createElement("path", {
    d: "M3 18C3 17.4477 3.44772 17 4 17H20C20.5523 17 21 17.4477 21 18C21 18.5523 20.5523 19 20 19H4C3.44772 19 3 18.5523 3 18Z",
    fill: "currentColor"
  })));
};

var _path$b, _path2$6, _path3$3;

function _extends$c() { _extends$c = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$c.apply(this, arguments); }

var SvgNotificationsIcon = function SvgNotificationsIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$c({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$b || (_path$b = /*#__PURE__*/React.createElement("path", {
    d: "M17.6806 17.4H11.64H5.59943C4.86919 17.4 4.60281 16.4383 5.22899 16.0626L6.6 15.24V8.04C6.6 5.25649 8.85648 3 11.64 3C14.4235 3 16.68 5.25648 16.68 8.04V14.8323C16.68 15.0853 16.8127 15.3196 17.0296 15.4497L18.051 16.0626C18.6772 16.4383 18.4108 17.4 17.6806 17.4Z",
    fill: "currentColor"
  })), _path2$6 || (_path2$6 = /*#__PURE__*/React.createElement("path", {
    d: "M10.2001 19.5599H13.0801C13.0801 20.3552 12.4354 20.9999 11.6401 20.9999C10.8448 20.9999 10.2001 20.3552 10.2001 19.5599Z",
    fill: "currentColor"
  })), _path3$3 || (_path3$3 = /*#__PURE__*/React.createElement("path", {
    d: "M10.2001 4.44V5.88C10.2001 6.67529 10.8448 7.32 11.6401 7.32C12.4354 7.32 13.0801 6.67529 13.0801 5.88V4.44C13.0801 3.64471 12.4354 3 11.6401 3C10.8448 3 10.2001 3.64471 10.2001 4.44Z",
    fill: "currentColor"
  })));
};

var _path$a;

function _extends$b() { _extends$b = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$b.apply(this, arguments); }

var SvgPaletteIcon = function SvgPaletteIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$b({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$a || (_path$a = /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M14 17H16.75C19.6495 17 22 14.6495 22 11.75V11.1667C22 6.10406 17.8959 2 12.8333 2H11.75C6.36522 2 2 6.36522 2 11.75C2 17.1348 6.36522 21.5 11.75 21.5H14.25C14.9404 21.5 15.5 20.9404 15.5 20.25V19.7143C15.5 19.3198 15.1802 19 14.7857 19H14C13.4477 19 13 18.5523 13 18C13 17.4477 13.4477 17 14 17ZM5.5 13C6.32843 13 7 12.3284 7 11.5C7 10.6716 6.32843 10 5.5 10C4.67157 10 4 10.6716 4 11.5C4 12.3284 4.67157 13 5.5 13ZM9.5 8C10.3284 8 11 7.32843 11 6.5C11 5.67157 10.3284 5 9.5 5C8.67157 5 8 5.67157 8 6.5C8 7.32843 8.67157 8 9.5 8ZM14.5 8C15.3284 8 16 7.32843 16 6.5C16 5.67157 15.3284 5 14.5 5C13.6716 5 13 5.67157 13 6.5C13 7.32843 13.6716 8 14.5 8ZM18.5 13C19.3284 13 20 12.3284 20 11.5C20 10.6716 19.3284 10 18.5 10C17.6716 10 17 10.6716 17 11.5C17 12.3284 17.6716 13 18.5 13Z",
    fill: "currentColor"
  })));
};

var _path$9, _path2$5, _circle;

function _extends$a() { _extends$a = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }

var SvgPhotoIcon = function SvgPhotoIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$a({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$9 || (_path$9 = /*#__PURE__*/React.createElement("path", {
    d: "M10.5484 16.6548C10.1346 17.041 9.47117 16.9539 9.17115 16.4738L7.5 13.8L3 17.85V20.1C3 20.5971 3.40294 21 3.9 21H20.1C20.5971 21 21 20.5971 21 20.1V16.6987L16.5 11.1L10.5484 16.6548Z",
    fill: "currentColor"
  })), _path2$5 || (_path2$5 = /*#__PURE__*/React.createElement("path", {
    d: "M21 16.6987L16.5 11.1L10.5484 16.6548C10.1346 17.041 9.47117 16.9539 9.17115 16.4738L7.5 13.8L3 17.85M21 16.6987V3.9M21 16.6987V20.1M3 3.9C3 3.40294 3.40294 3 3.9 3M3 3.9V3.9C3 3.40294 3.40294 3 3.9 3V3M3 3.9V17.85M3.9 3H20.1M20.1 3C20.5971 3 21 3.40294 21 3.9M20.1 3V3C20.5971 3 21 3.40294 21 3.9V3.9M21 20.1C21 20.5971 20.5971 21 20.1 21M21 20.1V20.1C21 20.5971 20.5971 21 20.1 21V21M20.1 21H3.9C3.40294 21 3 20.5971 3 20.1V17.85",
    stroke: "currentColor",
    strokeWidth: 1.35
  })), _circle || (_circle = /*#__PURE__*/React.createElement("circle", {
    cx: 7,
    cy: 7,
    r: 2,
    fill: "currentColor"
  })));
};

var _rect, _rect2;

function _extends$9() { _extends$9 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }

var SvgPauseIcon = function SvgPauseIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$9({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _rect || (_rect = /*#__PURE__*/React.createElement("rect", {
    x: 6,
    y: 4,
    width: 3,
    height: 16,
    rx: 1,
    fill: "currentColor"
  })), _rect2 || (_rect2 = /*#__PURE__*/React.createElement("rect", {
    x: 15,
    y: 4,
    width: 3,
    height: 16,
    rx: 1,
    fill: "currentColor"
  })));
};

var _path$8;

function _extends$8() { _extends$8 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }

var SvgPlayIcon = function SvgPlayIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$8({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$8 || (_path$8 = /*#__PURE__*/React.createElement("path", {
    d: "M17.2111 11.1056L6.44721 5.72361C5.78231 5.39116 5 5.87465 5 6.61803V17.382C5 18.1253 5.78231 18.6088 6.44722 18.2764L17.2111 12.8944C17.9482 12.5259 17.9482 11.4741 17.2111 11.1056Z",
    fill: "currentColor"
  })));
};

var _path$7, _path2$4;

function _extends$7() { _extends$7 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }

var SvgRepostIcon = function SvgRepostIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$7({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$7 || (_path$7 = /*#__PURE__*/React.createElement("path", {
    d: "M4 12.703L19.8743 3L12.5897 14.6579L4 12.703Z",
    fill: "currentColor"
  })), _path2$4 || (_path2$4 = /*#__PURE__*/React.createElement("path", {
    d: "M19.6301 21.9055L20.096 3.3064L13.6423 15.444L19.6301 21.9055Z",
    fill: "currentColor"
  })));
};

var _path$6, _path2$3, _path3$2, _path4$1, _path5$1, _path6$1, _path7$1;

function _extends$6() { _extends$6 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }

var SvgSelectionsIcon = function SvgSelectionsIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$6({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$6 || (_path$6 = /*#__PURE__*/React.createElement("path", {
    d: "M3 7V19C3 19.5523 3.44772 20 4 20H18C18.5523 20 19 19.5523 19 19V7C19 6.44772 18.5523 6 18 6H4C3.44772 6 3 6.44772 3 7Z",
    stroke: "currentColor",
    strokeWidth: 1.5
  })), _path2$3 || (_path2$3 = /*#__PURE__*/React.createElement("path", {
    d: "M6 8C6.55228 8 7 8.44772 7 9C7 9.55228 6.55228 10 6 10C5.44772 10 5 9.55228 5 9C5 8.44772 5.44772 8 6 8Z",
    fill: "currentColor"
  })), _path3$2 || (_path3$2 = /*#__PURE__*/React.createElement("path", {
    d: "M8.5 8H12.5M7 9V9C7 9.55228 6.55228 10 6 10V10C5.44772 10 5 9.55228 5 9V9C5 8.44772 5.44772 8 6 8V8C6.55228 8 7 8.44772 7 9Z",
    stroke: "currentColor"
  })), _path4$1 || (_path4$1 = /*#__PURE__*/React.createElement("path", {
    d: "M8.5 9.5H15",
    stroke: "currentColor",
    strokeWidth: 0.5
  })), _path5$1 || (_path5$1 = /*#__PURE__*/React.createElement("path", {
    d: "M5 11.5H15",
    stroke: "currentColor",
    strokeWidth: 0.5
  })), _path6$1 || (_path6$1 = /*#__PURE__*/React.createElement("path", {
    d: "M16 13H6C5.44772 13 5 13.4477 5 14V19C5 19.5523 5.44772 20 6 20H16C16.5523 20 17 19.5523 17 19V14C17 13.4477 16.5523 13 16 13Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 0.5
  })), _path7$1 || (_path7$1 = /*#__PURE__*/React.createElement("path", {
    d: "M20 18V18C20.5523 18 21 17.5523 21 17V5C21 4.44772 20.5523 4 20 4H6C5.44772 4 5 4.44772 5 5V5",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$5;

function _extends$5() { _extends$5 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }

var SvgSendIcon = function SvgSendIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$5({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$5 || (_path$5 = /*#__PURE__*/React.createElement("path", {
    d: "M21.4633 11.7317L2.72361 2.3618C2.39116 2.19558 2 2.43733 2 2.80902V7.62523C2 7.84734 2.14652 8.04283 2.35972 8.10515L15.3558 11.904C15.4518 11.9321 15.4518 12.0679 15.3558 12.096L2.35972 15.8949C2.14652 15.9572 2 16.1527 2 16.3748V21.191C2 21.5627 2.39116 21.8044 2.72361 21.6382L21.4633 12.2683C21.6845 12.1578 21.6845 11.8422 21.4633 11.7317Z",
    fill: "currentColor"
  })));
};

var _path$4, _path2$2, _path3$1, _path4, _path5, _path6, _path7, _path8, _path9;

function _extends$4() { _extends$4 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }

var SvgSettingsIcon = function SvgSettingsIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$4({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$4 || (_path$4 = /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M19.159 12C19.159 14.939 17.1669 17.4393 14.3863 18.3659C13.6399 18.6147 12.8367 18.75 12 18.75C11.1633 18.75 10.3601 18.6147 9.61367 18.3659C6.83315 17.4393 4.84102 14.939 4.84102 12C4.84102 9.06104 6.83315 6.56076 9.61367 5.63413C10.3601 5.38539 11.1633 5.25004 12 5.25004C12.8367 5.25004 13.6399 5.38539 14.3863 5.63413C17.1669 6.56076 19.159 9.06104 19.159 12ZM12 15.375C13.9769 15.375 15.5795 13.864 15.5795 12C15.5795 10.1361 13.9769 8.62504 12 8.62504C10.0231 8.62504 8.42051 10.1361 8.42051 12C8.42051 13.864 10.0231 15.375 12 15.375Z",
    fill: "currentColor"
  })), _path2$2 || (_path2$2 = /*#__PURE__*/React.createElement("path", {
    d: "M9.61367 5.63413C10.3601 5.38539 11.1633 5.25004 12 5.25004C12.8367 5.25004 13.6399 5.38539 14.3863 5.63413L13.8905 3.44503C13.8318 3.18549 13.5886 3 13.3071 3H10.6929C10.4114 3 10.1682 3.18549 10.1095 3.44503L9.61367 5.63413Z",
    fill: "currentColor"
  })), _path3$1 || (_path3$1 = /*#__PURE__*/React.createElement("path", {
    d: "M12 18.75C11.1633 18.75 10.3601 18.6147 9.61367 18.3659L10.1095 20.555C10.1682 20.8145 10.4114 21 10.6929 21H13.3071C13.5886 21 13.8318 20.8145 13.8905 20.555L14.3863 18.3659C13.6399 18.6147 12.8367 18.75 12 18.75Z",
    fill: "currentColor"
  })), _path4 || (_path4 = /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M15.5795 6.15436C18.279 7.62386 19.5794 10.5007 19.0402 13.2344C18.8955 13.9683 18.6182 14.6918 18.1999 15.375C17.7815 16.0583 17.2556 16.6465 16.6539 17.1315C14.4125 18.9387 11.12 19.3152 8.42052 17.8457C5.72107 16.3762 4.42062 13.4994 4.95978 10.7656C5.10451 10.0318 5.38179 9.30827 5.80016 8.62504C6.21852 7.9418 6.74444 7.35362 7.3461 6.86852C9.58748 5.0614 12.88 4.68487 15.5795 6.15436ZM15.0999 13.6875C16.0884 12.0733 15.5018 10.0092 13.7898 9.0772C12.0777 8.14522 9.88853 8.6983 8.90009 10.3125C7.91164 11.9268 8.49822 13.9909 10.2103 14.9229C11.9223 15.8549 14.1115 15.3018 15.0999 13.6875Z",
    fill: "currentColor"
  })), _path5 || (_path5 = /*#__PURE__*/React.createElement("path", {
    d: "M4.95978 10.7656C5.10451 10.0318 5.38179 9.30827 5.80016 8.62504C6.21852 7.9418 6.74444 7.35362 7.3461 6.86852L5.08753 6.17881C4.81975 6.09704 4.52779 6.20286 4.38706 6.4327L3.07995 8.56734C2.93921 8.79717 2.988 9.08848 3.19699 9.26625L4.95978 10.7656Z",
    fill: "currentColor"
  })), _path6 || (_path6 = /*#__PURE__*/React.createElement("path", {
    d: "M18.1999 15.375C17.7815 16.0583 17.2556 16.6465 16.6539 17.1315L18.9124 17.8212C19.1802 17.903 19.4722 17.7972 19.6129 17.5673L20.92 15.4327C21.0607 15.2029 21.012 14.9115 20.803 14.7338L19.0402 13.2344C18.8955 13.9683 18.6182 14.6918 18.1999 15.375Z",
    fill: "currentColor"
  })), _path7 || (_path7 = /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M15.5795 17.8457C12.88 19.3152 9.58745 18.9386 7.34608 17.1315C6.74442 16.6464 6.2185 16.0582 5.80014 15.375C5.38177 14.6918 5.10449 13.9682 4.95976 13.2344C4.4206 10.5006 5.72105 7.62383 8.4205 6.15433C11.12 4.68483 14.4125 5.06136 16.6539 6.86849C17.2556 7.35359 17.7815 7.94177 18.1998 8.625C18.6182 9.30824 18.8955 10.0318 19.0402 10.7656C19.5794 13.4994 18.2789 16.3762 15.5795 17.8457ZM8.90006 13.6875C9.88851 15.3017 12.0777 15.8548 13.7897 14.9228C15.5018 13.9909 16.0884 11.9267 15.0999 10.3125C14.1115 8.69827 11.9223 8.14518 10.2102 9.07717C8.4982 10.0091 7.91162 12.0733 8.90006 13.6875Z",
    fill: "currentColor"
  })), _path8 || (_path8 = /*#__PURE__*/React.createElement("path", {
    d: "M16.6539 6.86849C17.2556 7.35359 17.7815 7.94177 18.1998 8.625C18.6182 9.30824 18.8955 10.0318 19.0402 10.7656L20.803 9.26622C21.012 9.08845 21.0608 8.79714 20.92 8.5673L19.6129 6.43266C19.4722 6.20283 19.1802 6.09701 18.9125 6.17878L16.6539 6.86849Z",
    fill: "currentColor"
  })), _path9 || (_path9 = /*#__PURE__*/React.createElement("path", {
    d: "M5.80014 15.375C5.38177 14.6918 5.10449 13.9682 4.95976 13.2344L3.19704 14.7337C2.98805 14.9115 2.93926 15.2028 3.08 15.4327L4.38711 17.5673C4.52784 17.7971 4.8198 17.903 5.08758 17.8212L7.34608 17.1315C6.74442 16.6464 6.2185 16.0582 5.80014 15.375Z",
    fill: "currentColor"
  })));
};

var _path$3, _path2$1;

function _extends$3() { _extends$3 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }

var SvgShareIcon = function SvgShareIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$3({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$3 || (_path$3 = /*#__PURE__*/React.createElement("path", {
    d: "M7.786 11.214L4.30014 14.6999C3.30603 15.694 3.30603 17.3057 4.30014 18.2999L4.94287 18.9426C5.93698 19.9367 7.54876 19.9367 8.54287 18.9426L12.2612 15.2242C13.2553 14.2301 13.2553 12.6184 12.2612 11.6242L12.1751 11.5381",
    stroke: "currentColor",
    strokeWidth: 1.52735
  })), _path2$1 || (_path2$1 = /*#__PURE__*/React.createElement("path", {
    d: "M15.2142 12.7859L18.7001 9.30002C19.6942 8.30591 19.6942 6.69413 18.7001 5.70002L18.0574 5.05729C17.0633 4.06318 15.4515 4.06318 14.4574 5.05729L10.739 8.77563C9.74492 9.76974 9.74492 11.3815 10.739 12.3756L10.8251 12.4617",
    stroke: "currentColor",
    strokeWidth: 1.52735
  })));
};

var _path$2;

function _extends$2() { _extends$2 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

var SvgVerifiedBoldIcon = function SvgVerifiedBoldIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$2({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$2 || (_path$2 = /*#__PURE__*/React.createElement("path", {
    d: "M20 7L10.25 17.5L5 11.5",
    stroke: "currentColor",
    strokeWidth: 1.5
  })));
};

var _path$1;

function _extends$1() { _extends$1 = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

var SvgHomeIcon = function SvgHomeIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$1({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path$1 || (_path$1 = /*#__PURE__*/React.createElement("path", {
    d: "M4 10.2269V20.5C4 20.7761 4.22386 21 4.5 21H9C9.27614 21 9.5 20.7761 9.5 20.5V16.0022C9.5 16.0007 9.50015 15.9993 9.50045 15.9979C10.065 13.2879 13.935 13.2879 14.4996 15.9979C14.4999 15.9993 14.5 16.0007 14.5 16.0022V20.5C14.5 20.7761 14.7239 21 15 21H19.5C19.7761 21 20 20.7761 20 20.5V10.2269C20 10.0827 19.9378 9.94554 19.8293 9.8506L12.3293 3.2881C12.1407 3.12315 11.8593 3.12315 11.6707 3.2881L4.17075 9.8506C4.06224 9.94554 4 10.0827 4 10.2269Z",
    fill: "currentColor",
    stroke: "currentColor",
    strokeWidth: 1.53
  })));
};

var _path, _path2, _path3;

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var SvgMoreIcon = function SvgMoreIcon(props) {
  return /*#__PURE__*/React.createElement("svg", _extends({
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), _path || (_path = /*#__PURE__*/React.createElement("path", {
    d: "M10 5C10 3.89543 10.8954 3 12 3C13.1046 3 14 3.89543 14 5C14 6.10457 13.1046 7 12 7C10.8954 7 10 6.10457 10 5Z",
    fill: "currentColor"
  })), _path2 || (_path2 = /*#__PURE__*/React.createElement("path", {
    d: "M10 12C10 10.8954 10.8954 10 12 10C13.1046 10 14 10.8954 14 12C14 13.1046 13.1046 14 12 14C10.8954 14 10 13.1046 10 12Z",
    fill: "currentColor"
  })), _path3 || (_path3 = /*#__PURE__*/React.createElement("path", {
    d: "M10 19C10 17.8954 10.8954 17 12 17C13.1046 17 14 17.8954 14 19C14 20.1046 13.1046 21 12 21C10.8954 21 10 20.1046 10 19Z",
    fill: "currentColor"
  })));
};

export { AdaptiveList, SvgAddIcon as AddIcon, Alert, AppRoot, SvgAttachIcon as AttachIcon, Avatar, SvgBackBoldIcon as BackBoldIcon, SvgBotIcon as BotIcon, Button, Card, Cell, CellButton, SvgCoinIcon as CoinIcon, SvgCommentsIcon as CommentsIcon, ContextMenu, SvgDebugIcon as DebugIcon, SvgDeleteIcon as DeleteIcon, Dialog, SvgDialogsIcon as DialogsIcon, Div, SvgDoneIcon as DoneIcon, SvgDownloadIcon as DownloadIcon, SvgFeedIcon as FeedIcon, FloatingActionButton, SvgFollowersIcon as FollowersIcon, FormLayout, Group, GroupRoot, Header, SvgHomeIcon as HomeIcon, HorizontalList, Hosts, IconButton, SvgInfoIcon as InfoIcon, SvgLikeIcon as LikeIcon, Link, SvgLogoutIcon as LogoutIcon, SvgMailIcon as MailIcon, SvgMenuIcon as MenuIcon, MiniCell, ModalRoot, SvgMoreIcon as MoreIcon, NavigationBottomItem, NavigationListItem, SvgNotificationsIcon as NotificationsIcon, SvgPaletteIcon as PaletteIcon, Panel, PanelSpinner, SvgPauseIcon as PauseIcon, SvgPhotoIcon as PhotoIcon, SvgPlayIcon as PlayIcon, SvgRepostIcon as RepostIcon, SvgSelectionsIcon as SelectionsIcon, SvgSendIcon as SendIcon, SvgSettingsIcon as SettingsIcon, SvgShareIcon as ShareIcon, Spinner, Switch, Tabs, TabsItem, TextArea, TextInput, Toolbar, SvgUserIcon as UserIcon, SvgVerifiedBoldIcon as VerifiedIcon, View, ViewPager, classNames, harmonize };
//# sourceMappingURL=index.es.js.map
